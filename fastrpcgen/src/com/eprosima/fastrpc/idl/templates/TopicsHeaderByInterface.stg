/*************************************************************************
 * Copyright (c) 2013 eProsima. All rights reserved.
 *
 * This copy of FASTRPC is licensed to you under the terms described in the
 * FASTRPC_LICENSE file included in this distribution.
 *
 *************************************************************************/

group TopicsHeaderByInterface;

main(ctx, definitions) ::= <<
$fileHeader(ctx=ctx,  file=[ctx.filename, "Topics.h"], description=["This header file contains the declaration of topics generated using operations in the IDL file."])$

#ifndef _$ctx.filename;format="toUpper"$_TOPICS_H_
#define _$ctx.filename;format="toUpper"$_TOPICS_H_

#include "$ctx.filename$.h"
#include "$ctx.product$/protocols/dds/MessageHeader.h"
#include "$ctx.product$/utils/Messages.h"

#include <cstddef>

#if defined(_WIN32)
#if defined(EPROSIMA_USER_DLL_EXPORT)
#define user_cpp_DllExport __declspec( dllexport )
#else
#define user_cpp_DllExport
#endif
#else
#define user_cpp_DllExport
#endif

$definitions; separator="\n"$

#endif // _$ctx.filename;format="toUpper"$_TOPICS_H_
>>

module(ctx, module, definition_list) ::= <<
namespace $module.name$
{
    $definition_list$
}
>>

definition_list(definitions) ::= <<
$definitions; separator="\n"$
>>

interface(ctx, interface, export_list) ::= <<
$export_list$

$interface.all_operations : { operation |
/*!
 * @brief This class represents the structure $interface.name$_$operation.name$_In that can be used to send/receive requests
 * for the operation $interface.name$::$operation.name$.
 * @ingroup $ctx.trimfilename$
 */
class user_cpp_DllExport $interface.name$_$operation.name$_In
{
public:

    /*!
     * @brief Default constructor.
     */
    $interface.name$_$operation.name$_In();
    
    /*!
     * @brief Destructor.
     */
    ~$interface.name$_$operation.name$_In();
    
    /*
     * @brief Copy constructor.
     * @param x Reference to the object $interface.name$_$operation.name$_In that will be copied.
     */
    $interface.name$_$operation.name$_In(const $interface.name$_$operation.name$_In &x);
    
    /*!
     * @brief Move constructor.
     * @param x Reference to the object $interface.name$_$operation.name$_In that will be copied.
     */
    $interface.name$_$operation.name$_In($interface.name$_$operation.name$_In &&x);

    /*!
     * @brief Copy assignment.
     * @param x Reference to the object $interface.name$_$operation.name$ that will be copied.
     */
    $interface.name$_$operation.name$_In& operator=(const $interface.name$_$operation.name$_In &x);

    /*!
     * @brief Copy assignment.
     * @param x Reference to the object $interface.name$_$operation.name$ that will be copied.
     */
    $interface.name$_$operation.name$_In& operator=($interface.name$_$operation.name$_In &&x);

    $if(operation.inputparam)$
    $operation.inputparam:{$public_parameters_declaration(it)$}; separator="\n"$
    $else$
    inline void dummy(int32_t _dummy)
    {
        m_dummy = _dummy;
    }

    inline int32_t dummy() const
    {
        return m_dummy;
    }

    inline int32_t& dummy()
    {
        return m_dummy;
    }
    $endif$

    /*!
     * @brief This function returns the maximum serialized size of an object
     * depending on the buffer alignment.
     * @param current_alignment Buffer alignment.
     * @return Maximum serialized size.
     */
    static size_t getMaxCdrSerializedSize(size_t current_alignment = 0);

    /*!
     * @brief This function returns the serialized size of an object
     * depending on the buffer alignment.
     * @param current_alignment Buffer alignment.
     * @return Serialized size.
     */
    size_t getSerializedSize(size_t current_alignment = 0) const;

    /*!
     * @brief This function serializes an object using CDR serialization.
     * @param cdr CDR serialization object.
     */
    void serialize(eprosima::fastcdr::Cdr &cdr) const;

    /*!
     * @brief This function deserializes an object using CDR serialization.
     * @param cdr CDR serialization object.
     */
    void deserialize(eprosima::fastcdr::Cdr &cdr);

private:

    $if(operation.inputparam)$
    $operation.inputparam:{ param |$param.typecode.cppTypename$ m_$param.name$;}; separator="\n"$
    $else$
    int32_t m_dummy;
    $endif$
};

$if(!operation.oneway)$
/*!
 * @brief This class encapsulates output paramaters for operation $interface.name$::$operation.name$.
 * @ingroup $ctx.trimfilename$
 */
class user_cpp_DllExport $interface.name$_$operation.name$_Out
{
public:
    /*!
     * @brief Default constructor.
     */
    $interface.name$_$operation.name$_Out();
    
    /*!
     * @brief Destructor.
     */
    ~$interface.name$_$operation.name$_Out();
    
    /*!
     * @brief Copy constructor.
     * @param x Reference to the object $interface.name$_$operation.name$_Out that will be copied.
     */
    $interface.name$_$operation.name$_Out(const $interface.name$_$operation.name$_Out &x);
    
    /*!
     * @brief Move constructor.
     * @param x Reference to the object $interface.name$_$operation.name$_Out that will be copied.
     */
    $interface.name$_$operation.name$_Out($interface.name$_$operation.name$_Out &&x);

    /*!
     * @brief Copy assignment.
     * @param x Reference to the object $interface.name$_$operation.name$ that will be copied.
     */
    $interface.name$_$operation.name$_Out& operator=(const $interface.name$_$operation.name$_Out &x);

    /*!
     * @brief Copy assignment.
     * @param x Reference to the object $interface.name$_$operation.name$ that will be copied.
     */
    $interface.name$_$operation.name$_Out& operator=($interface.name$_$operation.name$_Out &&x);

    $if([operation.outputparam, operation.rettypeparam])$
    $[operation.outputparam, operation.rettypeparam]:{param |$public_parameters_declaration(param=param)$}; separator="\n"$
    $else$
    inline void dummy(int32_t _dummy)
    {
        m_dummy = _dummy;
    }

    inline int32_t dummy() const
    {
        return m_dummy;
    }

    inline int32_t& dummy()
    {
        return m_dummy;
    }
    $endif$

    /*!
     * @brief This function returns the maximum serialized size of an object
     * depending on the buffer alignment.
     * @param current_alignment Buffer alignment.
     * @return Maximum serialized size.
     */
    static size_t getMaxCdrSerializedSize(size_t current_alignment = 0);

    /*!
     * @brief This function returns the serialized size of an object
     * depending on the buffer alignment.
     * @param current_alignment Buffer alignment.
     * @return Serialized size.
     */
    size_t getSerializedSize(size_t current_alignment = 0) const;

    /*!
     * @brief This function serializes an object using CDR serialization.
     * @param cdr CDR serialization object.
     */
    void serialize(eprosima::fastcdr::Cdr &cdr) const;

    /*!
     * @brief This function deserializes an object using CDR serialization.
     * @param cdr CDR serialization object.
     */
    void deserialize(eprosima::fastcdr::Cdr &cdr);

private:

    $if([operation.outputparam, operation.rettypeparam])$
    $[operation.outputparam, operation.rettypeparam]:{ param |$param.typecode.cppTypename$ m_$param.name$;}; separator="\n"$
    $else$
    int32_t m_dummy;
    $endif$
};

/*!
 * @brief This class represents the structure $interface.name$_$operation.name$_Result that can be used to send/receive replies
 * for the operation $interface.name$::$operation.name$.
 * 
 * @ingroup $ctx.trimfilename$
 */
class user_cpp_DllExport $interface.name$_$operation.name$_Result
{
public:

    /*!
     * @brief Default constructor.
     */
    $interface.name$_$operation.name$_Result();
    
    /*!
     * @brief Destructor.
     */
    ~$interface.name$_$operation.name$_Result();
    
    /*!
     * @brief Copy constructor.
     * @param x Reference to the object $interface.name$_$operation.name$_Result that will be copied.
     */
    $interface.name$_$operation.name$_Result(const $interface.name$_$operation.name$_Result &x);
    
    /*!
     * @brief Move constructor.
     * @param x Reference to the object $interface.name$_$operation.name$_Result that will be copied.
     */
    $interface.name$_$operation.name$_Result($interface.name$_$operation.name$_Result &&x);

    /*!
     * @brief Copy assignment.
     * @param x Reference to the object $interface.name$_$operation.name$ that will be copied.
     */
    $interface.name$_$operation.name$_Result& operator=(const $interface.name$_$operation.name$_Result &x);

    /*!
     * @brief Copy assignment.
     * @param x Reference to the object $interface.name$_$operation.name$ that will be copied.
     */
    $interface.name$_$operation.name$_Result& operator=($interface.name$_$operation.name$_Result &&x);

    /*!
     * @brief This function sets the discriminator value.
     * @param __d New value for the discriminator.
     * @exception eprosima::rpc::exception::BadParamException This exception is thrown if the new value doesn't correspond to the selected union member.
     */
    void _d(int32_t __d);
    
    /*!
     * @brief This function returns the value of the discriminator.
     * @return Value of the discriminator
     */
    int32_t _d() const;
    
    /*!
     * @brief This function returns a reference to the discriminator.
     * @return Reference to the discriminator.
     */
    int32_t& _d();

    void unknown_exception(eprosima::rpc::protocol::dds::UnknownException _unknown_exception);

    eprosima::rpc::protocol::dds::UnknownException unknown_exception() const;
    
    eprosima::rpc::protocol::dds::UnknownException& unknown_exception();

    $public_exception_union_member_declaration(typename=[interface.name, "_", operation.name, "_Out"], name="out_")$

    void sysx_(eprosima::rpc::ReturnMessage _sysx_);

    eprosima::rpc::ReturnMessage sysx_() const;
    
    eprosima::rpc::ReturnMessage& sysx_();

    $operation.exceptions : { exception |$public_exception_union_member_declaration(typename=exception.scopedname, name=[exception.formatedScopedname, "_ex"])$}; separator="\n"$

    /*!
     * @brief This function returns the maximum serialized size of an object
     * depending on the buffer alignment.
     * @param current_alignment Buffer alignment.
     * @return Maximum serialized size.
     */
    static size_t getMaxCdrSerializedSize(size_t current_alignment = 0);

    /*!
     * @brief This function returns the serialized size of an object
     * depending on the buffer alignment.
     * @param current_alignment Buffer alignment.
     * @return Serialized size.
     */
    size_t getSerializedSize(size_t current_alignment = 0) const;

    /*!
     * @brief This function serializes an object using CDR serialization.
     * @param cdr CDR serialization object.
     */
    void serialize(eprosima::fastcdr::Cdr &cdr) const;

    /*!
     * @brief This function deserializes an object using CDR serialization.
     * @param cdr CDR serialization object.
     */
    void deserialize(eprosima::fastcdr::Cdr &cdr);

private:

    int32_t m__d;

    eprosima::rpc::protocol::dds::UnknownException m_unknown_exception;

    $interface.name$_$operation.name$_Out m_out_;

    eprosima::rpc::ReturnMessage m_sysx_;

    $operation.exceptions : { exception |$exception.scopedname$ m_$exception.formatedScopedname$_ex;}; separator="\n"$
};

$endif$
}; separator="\n"$

/*!
 * @brief This class represents the union used in the DDS topic to encapsulate the operations in request samples.
 * @ingroup $ctx.trimfilename$
 */
class user_cpp_DllExport $interface.name$_Call
{
public:

    /*!
     * @brief Default constructor.
     */
    $interface.name$_Call();
    
    /*!
     * @brief Destructor.
     */
    ~$interface.name$_Call();
    
    /*!
     * @brief Copy constructor.
     * @param x Reference to the object $interface.name$_Call that will be copied.
     */
    $interface.name$_Call(const $interface.name$_Call &x);
    
    /*!
     * @brief Move constructor.
     * @param x Reference to the object $interface.name$_Call that will be copied.
     */
    $interface.name$_Call($interface.name$_Call &&x);
    
    /*!
     * @brief Copy assignment.
     * @param x Reference to the object $interface.name$_Call that will be copied.
     */
    $interface.name$_Call& operator=(const $interface.name$_Call &x);
    
    /*!
     * @brief Move assignment.
     * @param x Reference to the object $interface.name$_Call that will be copied.
     */
    $interface.name$_Call& operator=($interface.name$_Call &&x);
    
    /*!
     * @brief This function sets the discriminator value.
     * @param __d New value for the discriminator.
     * @exception eprosima::rpc::exception::BadParamException This exception is thrown if the new value doesn't correspond to the selected union member.
     */
    void _d(int32_t __d);
    
    /*!
     * @brief This function returns the value of the discriminator.
     * @return Value of the discriminator
     */
    int32_t _d() const;
    
    /*!
     * @brief This function returns a reference to the discriminator.
     * @return Reference to the discriminator.
     */
    int32_t& _d();

    void unknown_operation(eprosima::rpc::protocol::dds::UnknownOperation _unknown_operation);

    eprosima::rpc::protocol::dds::UnknownOperation unknown_operation() const;

    eprosima::rpc::protocol::dds::UnknownOperation& unknown_operation();

    $interface.all_operations : { operation |$public_operations_declaration(interface=interface, operation=operation, suffix="_In")$}; separator="\n"$

    /*!
     * @brief This function returns the maximum serialized size of an object
     * depending on the buffer alignment.
     * @param current_alignment Buffer alignment.
     * @return Maximum serialized size.
     */
    static size_t getMaxCdrSerializedSize(size_t current_alignment = 0);

    /*!
     * @brief This function returns the serialized size of an object
     * depending on the buffer alignment.
     * @param current_alignment Buffer alignment.
     * @return Serialized size.
     */
    size_t getSerializedSize(size_t current_alignment = 0) const;

    /*!
     * @brief This function serializes an object using CDR serialization.
     * @param cdr CDR serialization object.
     */
    void serialize(eprosima::fastcdr::Cdr &cdr) const;

    /*!
     * @brief This function deserializes an object using CDR serialization.
     * @param cdr CDR serialization object.
     */
    void deserialize(eprosima::fastcdr::Cdr &cdr);
    
private:
    int32_t m__d;

    eprosima::rpc::protocol::dds::UnknownOperation m_unknown_operation;
    $interface.all_operations : { operation |$interface.name$_$operation.name$_In m_$operation.name$;}; separator="\n"$
};

/*!
 * @brief This class represents the structure $interface.name$_Request that can be used to send/receive requests
 * for the interface $interface.name$.
 * @ingroup $ctx.trimfilename$
 */
class user_cpp_DllExport $interface.name$_Request
{
public:

    /*!
     * @brief Default constructor.
     */
    $interface.name$_Request();
    
    /*!
     * @brief Destructor.
     */
    ~$interface.name$_Request();
    
    /*!
     * @brief Copy constructor.
     * @param x Reference to the object $interface.name$_Request that will be copied.
     */
    $interface.name$_Request(const $interface.name$_Request &x);
    
    /*!
     * @brief Move constructor.
     * @param x Reference to the object $interface.name$_Request that will be copied.
     */
    $interface.name$_Request($interface.name$_Request &&x);

    /*!
     * @brief Copy assignment.
     * @param x Reference to the object $interface.name$ that will be copied.
     */
    $interface.name$_Request& operator=(const $interface.name$_Request &x);

    /*!
     * @brief Copy assignment.
     * @param x Reference to the object $interface.name$ that will be copied.
     */
    $interface.name$_Request& operator=($interface.name$_Request &&x);

    /*!
     * @brief This method sets the request header information.
     * @param _header Request header.
     */
    inline void header(const eprosima::rpc::protocol::dds::RequestHeader &_header)
    {
        m_header = _header;
    }

    /*!
     * @brief This method sets the request header information.
     * @param _header Request header.
     */
    inline void header(eprosima::rpc::protocol::dds::RequestHeader &&_header)
    {
        m_header = std::move(_header);
    }

    /*!
     * @brief This method returns the request header information.
     * @return Request header.
     */
    inline const eprosima::rpc::protocol::dds::RequestHeader& header() const
    {
        return m_header;
    }

    /*!
     * @brief This method returns the request header information.
     * @return Request header.
     */
    inline eprosima::rpc::protocol::dds::RequestHeader& header()
    {
        return m_header;
    }

    /*!
     * @brief This method sets the union that encapsulates the interface operations.
     * @param _request Union.
     */
    inline void request(const $interface.name$_Call &_request)
    {
        m_request = _request;
    }

    /*!
     * @brief This method sets the union that encapsulates the interface operations.
     * @param _request Union.
     */
    inline void request($interface.name$_Call &&_request)
    {
        m_request = std::move(_request);
    }

    /*!
     * @brief This method returns the union that encapsulates the interface operations.
     * @return Union.
     */
    inline const $interface.name$_Call& request() const
    {
        return m_request;
    }

    /*!
     * @brief This method returns the union that encapsulates the interface operations.
     * @return Union.
     */
    inline $interface.name$_Call& request()
    {
        return m_request;
    }

    /*!
     * @brief This function returns the maximum serialized size of an object
     * depending on the buffer alignment.
     * @param current_alignment Buffer alignment.
     * @return Maximum serialized size.
     */
    static size_t getMaxCdrSerializedSize(size_t current_alignment = 0);

    /*!
     * @brief This function returns the serialized size of an object
     * depending on the buffer alignment.
     * @param current_alignment Buffer alignment.
     * @return Serialized size.
     */
    size_t getSerializedSize(size_t current_alignment = 0) const;

    /*!
     * @brief This function serializes an object using CDR serialization.
     * @param cdr CDR serialization object.
     */
    void serialize(eprosima::fastcdr::Cdr &cdr) const;

    /*!
     * @brief This function deserializes an object using CDR serialization.
     * @param cdr CDR serialization object.
     */
    void deserialize(eprosima::fastcdr::Cdr &cdr);

private:

    eprosima::rpc::protocol::dds::RequestHeader m_header;

    $interface.name$_Call m_request;
};

/*!
 * @brief This class represents the union used in the DDS topic to encapsulate the operations in reply samples.
 * @ingroup $ctx.trimfilename$
 */
class user_cpp_DllExport $interface.name$_Return
{
public:

    /*!
     * @brief Default constructor.
     */
    $interface.name$_Return();
    
    /*!
     * @brief Destructor.
     */
    ~$interface.name$_Return();
    
    /*!
     * @brief Copy constructor.
     * @param x Reference to the object $interface.name$_Return that will be copied.
     */
    $interface.name$_Return(const $interface.name$_Return &x);
    
    /*!
     * @brief Move constructor.
     * @param x Reference to the object $interface.name$_Return that will be copied.
     */
    $interface.name$_Return($interface.name$_Return &&x);
    
    /*!
     * @brief Copy assignment.
     * @param x Reference to the object $interface.name$_Return that will be copied.
     */
    $interface.name$_Return& operator=(const $interface.name$_Return &x);
    
    /*!
     * @brief Move assignment.
     * @param x Reference to the object $interface.name$_Return that will be copied.
     */
    $interface.name$_Return& operator=($interface.name$_Return &&x);
    
    /*!
     * @brief This function sets the discriminator value.
     * @param __d New value for the discriminator.
     * @exception eprosima::rpc::exception::BadParamException This exception is thrown if the new value doesn't correspond to the selected union member.
     */
    void _d(int32_t __d);
    
    /*!
     * @brief This function returns the value of the discriminator.
     * @return Value of the discriminator
     */
    int32_t _d() const;
    
    /*!
     * @brief This function returns a reference to the discriminator.
     * @return Reference to the discriminator.
     */
    int32_t& _d();

    void unknown_operation(eprosima::rpc::protocol::dds::UnknownOperation _unknown_operation);

    eprosima::rpc::protocol::dds::UnknownOperation unknown_operation() const;

    eprosima::rpc::protocol::dds::UnknownOperation& unknown_operation();

    $interface.notAllOnewayOperations : { operation |$public_operations_declaration(interface=interface, operation=operation, suffix="_Result")$}; separator="\n"$

    /*!
     * @brief This function returns the maximum serialized size of an object
     * depending on the buffer alignment.
     * @param current_alignment Buffer alignment.
     * @return Maximum serialized size.
     */
    static size_t getMaxCdrSerializedSize(size_t current_alignment = 0);

    /*!
     * @brief This function returns the serialized size of an object
     * depending on the buffer alignment.
     * @param current_alignment Buffer alignment.
     * @return Serialized size.
     */
    size_t getSerializedSize(size_t current_alignment = 0) const;

    /*!
     * @brief This function serializes an object using CDR serialization.
     * @param cdr CDR serialization object.
     */
    void serialize(eprosima::fastcdr::Cdr &cdr) const;

    /*!
     * @brief This function deserializes an object using CDR serialization.
     * @param cdr CDR serialization object.
     */
    void deserialize(eprosima::fastcdr::Cdr &cdr);
    
private:
    int32_t m__d;

    eprosima::rpc::protocol::dds::UnknownOperation m_unknown_operation;

    $interface.notAllOnewayOperations : { operation |$interface.name$_$operation.name$_Result m_$operation.name$;}; separator="\n"$
};

/*!
 * @brief This class represents the structure $interface.name$_Reply that can be used to send/receive replies
 * for the interface $interface.name$.
 * @ingroup $ctx.trimfilename$
 */
class user_cpp_DllExport $interface.name$_Reply
{
public:

    /*!
     * @brief Default constructor.
     */
    $interface.name$_Reply();
    
    /*!
     * @brief Destructor.
     */
    ~$interface.name$_Reply();
    
    /*
     * @brief Copy constructor.
     * @param x Reference to the object $interface.name$_Reply that will be copied.
     */
    $interface.name$_Reply(const $interface.name$_Reply &x);
    
    /*!
     * @brief Move constructor.
     * @param x Reference to the object $interface.name$_Reply that will be copied.
     */
    $interface.name$_Reply($interface.name$_Reply &&x);

    /*!
     * @brief Copy assignment.
     * @param x Reference to the object $interface.name$ that will be copied.
     */
    $interface.name$_Reply& operator=(const $interface.name$_Reply &x);

    /*!
     * @brief Copy assignment.
     * @param x Reference to the object $interface.name$ that will be copied.
     */
    $interface.name$_Reply& operator=($interface.name$_Reply &&x);

    /*!
     * @brief This method sets the reply header information.
     * @param _header Reply header.
     */
    inline void header(const eprosima::rpc::protocol::dds::ReplyHeader &_header)
    {
        m_header = _header;
    }

    /*!
     * @brief This method sets the reply header information.
     * @param _header Reply header.
     */
    inline void header(eprosima::rpc::protocol::dds::ReplyHeader &&_header)
    {
        m_header = std::move(_header);
    }

    /*!
     * @brief This method returns the reply header information.
     * @return Reply header.
     */
    inline const eprosima::rpc::protocol::dds::ReplyHeader& header() const
    {
        return m_header;
    }

    /*!
     * @brief This method returns the reply header information.
     * @return Reply header.
     */
    inline eprosima::rpc::protocol::dds::ReplyHeader& header()
    {
        return m_header;
    }

    /*!
     * @brief This method sets the union that encapsulates the interface operations.
     * @param _reply Union.
     */
    inline void reply(const $interface.name$_Return &_reply)
    {
        m_reply = _reply;
    }

    /*!
     * @brief This method sets the union that encapsulates the interface operations.
     * @param _reply Union.
     */
    inline void reply($interface.name$_Return &&_reply)
    {
        m_reply = std::move(_reply);
    }

    /*!
     * @brief This method sets the union that encapsulates the interface operations.
     * @return Union.
     */
    inline const $interface.name$_Return& reply() const
    {
        return m_reply;
    }

    /*!
     * @brief This method sets the union that encapsulates the interface operations.
     * @return Union.
     */
    inline $interface.name$_Return& reply()
    {
        return m_reply;
    }

    /*!
     * @brief This function returns the maximum serialized size of an object
     * depending on the buffer alignment.
     * @param current_alignment Buffer alignment.
     * @return Maximum serialized size.
     */
    static size_t getMaxCdrSerializedSize(size_t current_alignment = 0);

    /*!
     * @brief This function returns the serialized size of an object
     * depending on the buffer alignment.
     * @param current_alignment Buffer alignment.
     * @return Serialized size.
     */
    size_t getSerializedSize(size_t current_alignment = 0) const;

    /*!
     * @brief This function serializes an object using CDR serialization.
     * @param cdr CDR serialization object.
     */
    void serialize(eprosima::fastcdr::Cdr &cdr) const;

    /*!
     * @brief This function deserializes an object using CDR serialization.
     * @param cdr CDR serialization object.
     */
    void deserialize(eprosima::fastcdr::Cdr &cdr);

private:

    eprosima::rpc::protocol::dds::ReplyHeader m_header;

    $interface.name$_Return m_reply;
};
>>

export_list(exports) ::= <<
$exports; separator="\n"$
>>

exception(ctx, exception) ::= <<>>

operation(ctx, operation, param_list) ::= <<>>

param_list(parameters) ::= <<>>

param(parameter) ::= <<>>

const_decl(ctx, const) ::= <<>>

typedef_decl(ctx, typedefs) ::= <<>>

struct_type(ctx, struct) ::= <<>>

union_type(ctx, union) ::= <<>>

enum_type(ctx, enum) ::= <<>>

/***** Utils *****/
public_operations_declaration(interface, operation, suffix) ::= <<
/*!
 * @brief This function copies the value in member $operation.name$
 * @param _$operation.name$ New value to be copied in member $operation.name$
 */
void $operation.name$(const $interface.name$_$operation.name$$suffix$ &_$operation.name$);

/*!
 * @brief This function moves the value in member $operation.name$
 * @param _$operation.name$ New value to be moved in member $operation.name$
 */
void $operation.name$($interface.name$_$operation.name$$suffix$ &&_$operation.name$);

/*!
 * @brief This function returns a constant reference to member $operation.name$
 * @return Constant reference to member $operation.name$
 */
const $interface.name$_$operation.name$$suffix$& $operation.name$() const;

/*!
 * @brief This function returns a reference to member $operation.name$
 * @return Reference to member $operation.name$
 */
$interface.name$_$operation.name$$suffix$& $operation.name$();
>>

public_parameters_declaration(param) ::= <<
$if(param.typecode.primitive)$
/*!
 * @brief This function sets a value in member $param.name$
 * @param _$param.name$ New value for member $param.name$
 */
inline void $param.name$($param.typecode.cppTypename$ _$param.name$)
{
    m_$param.name$ = _$param.name$;
}

/*!
 * @brief This function returns the value of member $param.name$
 * @return Value of member $param.name$
 */
inline $param.typecode.cppTypename$ $param.name$() const
{
    return m_$param.name$;
}

/*!
 * @brief This function returns a reference to member $param.name$
 * @return Reference to member $param.name$
 */
inline $param.typecode.cppTypename$& $param.name$()
{
    return m_$param.name$;
}
$else$
/*!
 * @brief This function copies the value in member $param.name$
 * @param _$param.name$ New value to be copied in member $param.name$
 */
inline void $param.name$(const $param.typecode.cppTypename$ &_$param.name$)
{
    m_$param.name$ = _$param.name$;
}

/*!
 * @brief This function moves the value in member $param.name$
 * @param _$param.name$ New value to be moved in member $param.name$
 */
inline void $param.name$($param.typecode.cppTypename$ &&_$param.name$)
{
    m_$param.name$ = std::move(_$param.name$);
}

/*!
 * @brief This function returns a constant reference to member $param.name$
 * @return Constant reference to member $param.name$
 */
inline const $param.typecode.cppTypename$& $param.name$() const
{
    return m_$param.name$;
}

/*!
 * @brief This function returns a reference to member $param.name$
 * @return Reference to member $param.name$
 */
inline $param.typecode.cppTypename$& $param.name$()
{
    return m_$param.name$;
}
$endif$
>>

public_exception_union_member_declaration(typename, name) ::= <<
/*!
 * @brief This function copies the value in member $name$
 * @param _$name$ New value to be copied in member $name$
 */
void $name$(const $typename$ &_$name$);

/*!
 * @brief This function moves the value in member $name$
 * @param _$name$ New value to be moved in member $name$
 */
void $name$($typename$ &&_$name$);

/*!
 * @brief This function returns a constant reference to member $name$
 * @return Constant reference to member $name$
 * @exception eprosima::rpc::exception::BadParamException This exception is thrown if the requested union member is not the current selection.
 */
const $typename$& $name$() const;

/*!
 * @brief This function returns a reference to member $name$
 * @return Reference to member $name$
 * @exception eprosima::rpc::exception::BadParamException This exception is thrown if the requested union member is not the current selection.
 */
$typename$& $name$();
>>
