/*************************************************************************
 * Copyright (c) 2013 eProsima. All rights reserved.
 *
 * This generated file is licensed to you under the terms described in the
 * fastrpc_LICENSE file included in this fastrpc distribution.
 *
 *************************************************************************
 * 
 * @file LatencyDDSProtocol.cxx
 * This source file contains the definition of the protocol used to create DDS messages.
 *
 * This file was generated by the tool fastrpcgen.
 */

#include "LatencyDDSProtocol.h"
#include "fastrpc/transports/Transport.h"
#include "fastrpc/transports/dds/ProxyTransport.h"
#include "fastrpc/transports/dds/components/ProxyProcedureEndpoint.h"
#include "LatencyDDSAsyncSupport.h"
#include "fastrpc/transports/dds/ServerTransport.h"
#include "fastrpc/transports/dds/components/ServerProcedureEndpoint.h"
#include "fastrpc/exceptions/Exceptions.h"
#include "LatencyTopicsPlugin.h"
using namespace eprosima::rpc;
using namespace ::protocol::dds;
using namespace ::transport;
using namespace ::exception;

LatencyProtocol::LatencyProtocol() : ::protocol::LatencyProtocol(), m_ddsTransport(NULL)

, Latency_str("Latency")
, Latency_pe(NULL), Latency_se(NULL)
{
}

LatencyProtocol::~LatencyProtocol()
{
}

bool LatencyProtocol::setTransport(Transport &transport)
{
    if(strcmp(transport.getType(), "DDS") == 0)
    {
        m_ddsTransport = dynamic_cast<eprosima::rpc::transport::dds::Transport*>(&transport);
        
        m_ddsTransport->initialize();
        
        Protocol::_setTransport(transport);
        
        return true;  
    }
    else
    {
        throw IncompatibleException("protocol and transport are incompatibles");
    }
    
    return false;
}

// TODO Si falla que elimine los creados.
bool LatencyProtocol::activateInterface(const char* interfaceName)
{
    const char *requesttypeName = NULL, *replytypeName = NULL;

    if(m_ddsTransport != NULL)
    {
        TransportBehaviour behaviour = dynamic_cast<Transport*>(m_ddsTransport)->getBehaviour();
        
        if(strcmp(interfaceName, "Latency") == 0)
        {
            requesttypeName = LatencyRequestPlugin::get_typename();
    
            if(!LatencyRequestPlugin::register_type(m_ddsTransport->getParticipant(), requesttypeName))
            {
                return false;
            }
            
            replytypeName = LatencyReplyPlugin::get_typename();
    
            if(!LatencyReplyPlugin::register_type(m_ddsTransport->getParticipant(), replytypeName))
            {
                return false;
            }
            
            if(behaviour == ::transport::PROXY_BEHAVIOUR)
            {
                Latency_pe = dynamic_cast<eprosima::rpc::transport::dds::ProxyProcedureEndpoint*>(m_ddsTransport->createProcedureEndpoint(Latency_str,
                requesttypeName,
                replytypeName,
                true,
                (::transport::dds::Transport::Create_data)LatencyReplyPlugin::create_data,
                (::transport::dds::Transport::Copy_data)LatencyReplyPlugin::copy_data,
                (::transport::dds::Transport::Destroy_data)LatencyReplyPlugin::destroy_data,
                NULL,
                sizeof(LatencyReply)
                ));
            }
            if(behaviour == ::transport::SERVER_BEHAVIOUR)
            {
                Latency_se = dynamic_cast<eprosima::rpc::transport::dds::ServerProcedureEndpoint*>(m_ddsTransport->createProcedureEndpoint(Latency_str,
                    replytypeName,
                    requesttypeName,
		            true,
                    (::transport::dds::Transport::Create_data)LatencyRequestPlugin::create_data,
                    (::transport::dds::Transport::Copy_data)LatencyRequestPlugin::copy_data,
                    (::transport::dds::Transport::Destroy_data)LatencyRequestPlugin::destroy_data,
                    LatencyProtocol::Latency_serve,
                    sizeof(LatencyRequest)));
            }
        }

    }
    else
    {
      // TODO Trace.
    }
    
    return false;
}



st LatencyProtocol::Latency_latency(/*in*/ const st& param)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    st  latency_ret;
    LatencyRequest instance;
    LatencyReply retInstance;



    instance.unio()._d() = 1;
    
    instance.unio().latency().param(param);

    retcode = Latency_pe->send(&instance, &retInstance);
    
    if(retcode == OPERATION_SUCCESSFUL)
    {
    
        retcode = (ReturnMessage)retInstance._header().retCode();
         
        latency_ret = std::move(retInstance.unio().latency().latency_ret()); //TODO Probar que esto funciona. 
    
    }
      
    switch (retcode)
    {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case NO_SERVER:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        case SERVER_TIMEOUT:
            throw ServerTimeoutException("Timeout waiting the server's reply");
            break;
        case SERVER_INTERNAL_ERROR:
            throw ServerInternalException(retInstance._header().retMsg());
            break;
        default:
            break;
    };
    

    return latency_ret;
}
void LatencyProtocol::Latency_latency_async(Latency_latencyCallbackHandler &obj, /*in*/ const st& param)
{
    ReturnMessage retcode = CLIENT_INTERNAL_ERROR;
    LatencyRequest instance;
    Latency_latencyTask *task = new Latency_latencyTask(obj);

    instance.unio()._d() = 1;
    
    instance.unio().latency().param(param);

    retcode = Latency_pe->send_async(&instance, task);
    
    switch (retcode)
    {
        case CLIENT_INTERNAL_ERROR:
            throw ClientInternalException("Error in client side");
            break;
        case NO_SERVER:
            throw ServerNotFoundException("Cannot connect to the server");
            break;
        default:
            break;
    }
}


void LatencyProtocol::Latency_serve(eprosima::rpc::protocol::Protocol &protocol,
    void *data , eprosima::rpc::transport::Endpoint *endpoint)
{
    LatencyProtocol &_protocol = dynamic_cast<LatencyProtocol&>(protocol);
    LatencyRequest &requestData = *(LatencyRequest*)data;

    switch(requestData.unio()._d())
    {

                case 1:
                {
                st  param;
                st  latency_ret;   
                LatencyReply replyData;
                replyData._header().clientId().value_1() = requestData._header().clientId().value_1();
                replyData._header().clientId().value_2() = requestData._header().clientId().value_2();
                replyData._header().clientId().value_3() = requestData._header().clientId().value_3();
                replyData._header().clientId().value_4() = requestData._header().clientId().value_4();
                replyData._header().requestSequenceNumber() = requestData._header().requestSequenceNumber();

                replyData.unio()._d() = 1;


                 
                param = std::move(requestData.unio().latency().param()); //TODO Probar que esto funciona. 

                try
                {
                    if(_protocol._Latency_impl != NULL)
                    {
                        latency_ret = _protocol._Latency_impl->latency(param);


                        replyData.unio().latency().latency_ret(std::move(latency_ret));

                        replyData._header().retCode(OPERATION_SUCCESSFUL);

                        _protocol.Latency_se->sendReply(&replyData);
                    }
                    // TODO Send exception.
                }
                catch(const ServerInternalException &ex)
                {
                    replyData._header().retCode(SERVER_INTERNAL_ERROR);
                    replyData._header().retMsg(std::move(ex.what()));

                    _protocol.Latency_se->sendReply(&replyData);
                }



                }
                break;
                
    };        
}