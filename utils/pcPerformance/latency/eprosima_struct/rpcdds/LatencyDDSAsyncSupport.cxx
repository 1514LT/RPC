/*************************************************************************
 * Copyright (c) 2013 eProsima. All rights reserved.
 *
 * This generated file is licensed to you under the terms described in the
 * fastrpc_LICENSE file included in this fastrpc distribution.
 *
 *************************************************************************
 * 
 * @file LatencyAsyncSupport.cxx
 * This source file contains functionality to use asynchronous calls for all interfaces.
 *
 * This file was generated by the tool fastrpcgen.
 */

#include "LatencyDDSAsyncSupport.h"
#include "fastrpc/exceptions/ServerInternalException.h"
#include "fastrpc/utils/Messages.h"

using namespace eprosima::rpc;
using namespace ::exception;



Latency_latencyTask::Latency_latencyTask(Latency_latencyCallbackHandler &obj) :
    DDSAsyncTask(), m_obj(obj)
{
}

Latency_latencyTask::~Latency_latencyTask()
{
}

Latency_latencyCallbackHandler& Latency_latencyTask::getObject()
{
    return m_obj;
}

void* Latency_latencyTask::getReplyInstance()
{
    return &m_reply;
}

void Latency_latencyTask::execute()
{  
    st  latency_ret;
    ReturnMessage retcode = OPERATION_SUCCESSFUL;
    
    retcode = (ReturnMessage)m_reply._header().retCode();
     
    latency_ret = std::move(m_reply.unio().latency().latency_ret()); //TODO Probar que esto funciona. 
        
    if(retcode == OPERATION_SUCCESSFUL)
    {
        getObject().latency(latency_ret);
    }
    else
    {
        if(retcode == SERVER_INTERNAL_ERROR)
            getObject().on_exception(ServerInternalException(m_reply._header().retMsg()));
    }
}

void Latency_latencyTask::on_exception(const SystemException &ex)
{
    getObject().on_exception(ex);
}

