/*************************************************************************
 * Copyright (c) 2013 eProsima. All rights reserved.
 *
 * This generated file is licensed to you under the terms described in the
 * fastrpc_LICENSE file included in this fastrpc distribution.
 *
 *************************************************************************
 * 
 * @file LatencyTopics.cpp
 * This source file contains the implementation of topics generated using operations in the IDL file.
 *
 * This file was generated by the tool fastrpcgen.
 */

#include "LatencyTopics.h"

#include "fastcdr/Cdr.h"
#include "fastrpc/exceptions/BadParamException.h"



Latency_latencyRequest::Latency_latencyRequest()
: m_param()
{
}

Latency_latencyRequest::~Latency_latencyRequest()
{
}

Latency_latencyRequest::Latency_latencyRequest(const Latency_latencyRequest &x)
: m_param(x.m_param)
{
}

Latency_latencyRequest::Latency_latencyRequest(Latency_latencyRequest &&x)
: m_param(std::move(x.m_param))
{
}

Latency_latencyRequest& Latency_latencyRequest::operator=(const Latency_latencyRequest &x)
{
    m_param = x.m_param;;
    
    return *this;
}

Latency_latencyRequest& Latency_latencyRequest::operator=(Latency_latencyRequest &&x)
{
    m_param = x.m_param;;
    
    return *this;
}

size_t Latency_latencyRequest::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;
            
    current_align += 4 + eprosima::fastcdr::Cdr::alignment(current_align, 4);
    for(size_t a = 0; a < 2048; ++a)
    {
        current_align = element::getMaxCdrSerializedSize(current_align);}


    return current_align;
}

size_t Latency_latencyRequest::getSerializedSize(size_t current_alignment) const
{
    size_t current_align = current_alignment;

    // TODO

    return current_align;
}

void Latency_latencyRequest::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    if(m_param.size() <= 2048)
    scdr << m_param;
    else
        throw eprosima::rpc::exception::BadParamException(std::string("param field exceeds the maximum length"));
}

void Latency_latencyRequest::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_param;
}

Latency_latencyReply::Latency_latencyReply()
: m_latency_ret()
{
}

Latency_latencyReply::~Latency_latencyReply()
{
}

Latency_latencyReply::Latency_latencyReply(const Latency_latencyReply &x)
: m_latency_ret(x.m_latency_ret)
{
}

Latency_latencyReply::Latency_latencyReply(Latency_latencyReply &&x)
: m_latency_ret(std::move(x.m_latency_ret))
{
}

Latency_latencyReply& Latency_latencyReply::operator=(const Latency_latencyReply &x)
{
    m_latency_ret = x.m_latency_ret;;
    
    return *this;
}

Latency_latencyReply& Latency_latencyReply::operator=(Latency_latencyReply &&x)
{
    m_latency_ret = x.m_latency_ret;;
    
    return *this;
}

size_t Latency_latencyReply::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;
            
    current_align += 4 + eprosima::fastcdr::Cdr::alignment(current_align, 4);
    for(size_t a = 0; a < 2048; ++a)
    {
        current_align = element::getMaxCdrSerializedSize(current_align);}


    return current_align;
}

size_t Latency_latencyReply::getSerializedSize(size_t current_alignment) const
{
    size_t current_align = current_alignment;

    // TODO

    return current_align;
}

void Latency_latencyReply::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    if(m_latency_ret.size() <= 2048)
    scdr << m_latency_ret;
    else
        throw eprosima::rpc::exception::BadParamException(std::string("latency_ret field exceeds the maximum length"));
}

void Latency_latencyReply::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_latency_ret;
}


LatencyRequest_union::LatencyRequest_union() : m__d(1)
{
}

LatencyRequest_union::~LatencyRequest_union()
{
}

LatencyRequest_union::LatencyRequest_union(const LatencyRequest_union &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {

                case 1:
                    m_latency = x.m_latency;
                    break;
                
    }
}

LatencyRequest_union::LatencyRequest_union(LatencyRequest_union &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {

                case 1:
                    m_latency = std::move(x.m_latency);
                    break;
                
    }
}

LatencyRequest_union& LatencyRequest_union::operator=(const LatencyRequest_union &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {

                case 1:
                    m_latency = x.m_latency;
                    break;
                
    }
    
    return *this;
}

LatencyRequest_union& LatencyRequest_union::operator=(LatencyRequest_union &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {

                case 1:
                    m_latency = std::move(x.m_latency);
                    break;
                
    }
    
    return *this;
}

void LatencyRequest_union::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t LatencyRequest_union::_d() const
{
    return m__d;
}

int32_t& LatencyRequest_union::_d()
{
    return m__d;
}


void LatencyRequest_union::latency(const Latency_latencyRequest &_latency)
{
    m_latency = _latency;
    m__d = 1;
}

void LatencyRequest_union::latency(Latency_latencyRequest &&_latency)
{
    m_latency = std::move(_latency);
    m__d = 1;
}

const Latency_latencyRequest& LatencyRequest_union::latency() const
{
    if(m__d != 1)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_latency;
}

Latency_latencyRequest& LatencyRequest_union::latency()
{
    if(m__d != 1)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_latency;
}


size_t LatencyRequest_union::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;
    size_t reset_align = 0;
    size_t union_max_size_serialized = 0;

    current_align += 4 + eprosima::fastcdr::Cdr::alignment(current_align, 4);


        reset_align = current_align;

        reset_align = Latency_latencyRequest::getMaxCdrSerializedSize(reset_align);

        if(union_max_size_serialized < reset_align)
            union_max_size_serialized = reset_align;

        

    return union_max_size_serialized;
}

size_t LatencyRequest_union::getSerializedSize(size_t current_alignment) const
{
    size_t current_align = current_alignment;
    // TODO Discriminator

    return current_align;
}

void LatencyRequest_union::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {

                case 1:
                    scdr << m_latency;
                    break;
                
    }
}

void LatencyRequest_union::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {

                case 1:
                    dcdr >> m_latency;
                    break;
                
    }
}

LatencyRequest::LatencyRequest()
{
}

LatencyRequest::~LatencyRequest()
{
}

LatencyRequest::LatencyRequest(const LatencyRequest &x)
: m__header(x.m__header), m_unio(x.m_unio)
{
}

LatencyRequest::LatencyRequest(LatencyRequest &&x)
: m__header(std::move(x.m__header)), m_unio(std::move(x.m_unio))
{
}

LatencyRequest& LatencyRequest::operator=(const LatencyRequest &x)
{
    m__header = x.m__header;
    m_unio = x.m_unio;
    
    return *this;
}

LatencyRequest& LatencyRequest::operator=(LatencyRequest &&x)
{
    m__header = std::move(x.m__header);
    m_unio = std::move(x.m_unio);
    
    return *this;
}

size_t LatencyRequest::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;
    current_align =  eprosima::rpc::protocol::dds::RequestHeader::getMaxCdrSerializedSize(current_align);
    current_align = LatencyRequest_union::getMaxCdrSerializedSize(current_align);
            
    return current_align;
}

size_t LatencyRequest::getSerializedSize(size_t current_alignment) const
{
    size_t current_align = current_alignment;
    // TODO Header and unio

    return current_align;
}

void LatencyRequest::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__header;
    scdr << m_unio;
}

void LatencyRequest::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__header;
    dcdr >> m_unio;
}

LatencyReply_union::LatencyReply_union() : m__d(1)
{
}

LatencyReply_union::~LatencyReply_union()
{
}

LatencyReply_union::LatencyReply_union(const LatencyReply_union &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {

                case 1:
                    m_latency = x.m_latency;
                    break;
                
    }
}

LatencyReply_union::LatencyReply_union(LatencyReply_union &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {

                case 1:
                    m_latency = std::move(x.m_latency);
                    break;
                
    }
}

LatencyReply_union& LatencyReply_union::operator=(const LatencyReply_union &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {

                case 1:
                    m_latency = x.m_latency;
                    break;
                
    }
    
    return *this;
}

LatencyReply_union& LatencyReply_union::operator=(LatencyReply_union &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {

                case 1:
                    m_latency = std::move(x.m_latency);
                    break;
                
    }
    
    return *this;
}

void LatencyReply_union::_d(int32_t __d)
{
    if(m__d != __d)
    {
        throw eprosima::rpc::exception::BadParamException("Discriminator doesn't correspond with the selected union member");
    }
    
    m__d = __d;
}

int32_t LatencyReply_union::_d() const
{
    return m__d;
}

int32_t& LatencyReply_union::_d()
{
    return m__d;
}


void LatencyReply_union::latency(const Latency_latencyReply &_latency)
{
    m_latency = _latency;
    m__d = 1;
}

void LatencyReply_union::latency(Latency_latencyReply &&_latency)
{
    m_latency = std::move(_latency);
    m__d = 1;
}

const Latency_latencyReply& LatencyReply_union::latency() const
{
    if(m__d != 1)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_latency;
}

Latency_latencyReply& LatencyReply_union::latency()
{
    if(m__d != 1)
        throw eprosima::rpc::exception::BadParamException("This member is not been selected");
    
    return m_latency;
}


size_t LatencyReply_union::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;
    size_t reset_align = 0;
    size_t union_max_size_serialized = 0;

    current_align += 4 + eprosima::fastcdr::Cdr::alignment(current_align, 4);


        reset_align = current_align;

        reset_align = Latency_latencyReply::getMaxCdrSerializedSize(reset_align);

        if(union_max_size_serialized < reset_align)
            union_max_size_serialized = reset_align;

        

    return union_max_size_serialized;
}

size_t LatencyReply_union::getSerializedSize(size_t current_alignment) const
{
    size_t current_align = current_alignment;
    // TODO Discriminator

    return current_align;
}

void LatencyReply_union::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {

                case 1:
                    scdr << m_latency;
                    break;
                
    }
}

void LatencyReply_union::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {

                case 1:
                    dcdr >> m_latency;
                    break;
                
    }
}

LatencyReply::LatencyReply()
{
}

LatencyReply::~LatencyReply()
{
}

LatencyReply::LatencyReply(const LatencyReply &x)
: m__header(x.m__header), m_unio(x.m_unio)
{
}

LatencyReply::LatencyReply(LatencyReply &&x)
: m__header(std::move(x.m__header)), m_unio(std::move(x.m_unio))
{
}

LatencyReply& LatencyReply::operator=(const LatencyReply &x)
{
    m__header = x.m__header;
    m_unio = x.m_unio;
    
    return *this;
}

LatencyReply& LatencyReply::operator=(LatencyReply &&x)
{
    m__header = std::move(x.m__header);
    m_unio = std::move(x.m_unio);
    
    return *this;
}

size_t LatencyReply::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t current_align = current_alignment;
    current_align =  eprosima::rpc::protocol::dds::ReplyHeader::getMaxCdrSerializedSize(current_align);
    current_align = LatencyReply_union::getMaxCdrSerializedSize(current_align);
            
    return current_align;
}

size_t LatencyReply::getSerializedSize(size_t current_alignment) const
{
    size_t current_align = current_alignment;
    // TODO Header and unio

    return current_align;
}

void LatencyReply::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__header;
    scdr << m_unio;
}

void LatencyReply::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__header;
    dcdr >> m_unio;
}
