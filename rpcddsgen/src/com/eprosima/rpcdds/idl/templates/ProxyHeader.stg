group ProxyHeader;

main(ctx, definitions) ::= <<
$fileHeader(file=[ctx.filename, "Proxy.h"], description=["This header file contains the declaration of the proxy for all interfaces."])$

#ifndef _$ctx.filename;format="toUpper"$_PROXY_H_
#define _$ctx.filename;format="toUpper"$_PROXY_H_

#include "client/Proxy.h"
#include "exceptions/SystemException.h"
#include "exceptions/UserException.h"
#include "utils/dds/Middleware.h"
#include "$ctx.filename$.h"

namespace eprosima
{
    namespace rpcdds
    {
        namespace protocol
        {
            class $ctx.filename$Protocol;
        }
    }
}

$definitions; separator="\n"$

#endif // _$ctx.filename;format="toUpper"$_PROXY_H_
>>

module(ctx, module, definition_list) ::= <<
namespace $module.name$
{
    $definition_list$
};

>>

definition_list(definitions) ::= <<
$definitions; separator="\n"$
>>

/*!
 * The export_list will be the definition of synchronize functions.
 */
interface(ctx, interface, export_list) ::= <<
$interface.exports : {export | $if(export.operation)$$classAsyncHeader(operation=export)$$endif$}$

/*!
 * @brief This class implements a specific server's proxy for the defined interface $interface.name$.
 */
class RPCDDSUSERDllExport $interface.name$Proxy : public eprosima::rpcdds::proxy::Proxy
{
    public:
   
        /*!
         * @brief This constructor sets the transport that will be used by the server's proxy.
         *
         * @param transport The network transport that server's proxy has to use.
         *        This transport's object is not deleted by this class in its destructor. Cannot be NULL.
         * @param protocol The protocol used to send the information over the transport.
         *        This protocol's object is not deleted by this class in its destructor. Cannot be NULL.
         * @exception eprosima::rpcdds::exception::InitializeException This exception is thrown when the initialization was wrong.
         */
        $interface.name$Proxy(eprosima::rpcdds::transport::ProxyTransport &transport,
            eprosima::rpcdds::protocol::$ctx.filename$Protocol &protocol);

        //! @brief The default destructor.
        virtual ~$interface.name$Proxy();
        
        $export_list$
        
        $interface.exports : {export | $if(export.operation)$//$functionAsyncHeader(operation=export)$$endif$}$
};

>>

export_list(exports) ::= <<
$exports; separator="\n"$
>>

exception(ctx, exception) ::= <<>>

operation(ctx, operation, param_list) ::= <<
//! @brief Proxy method for the operation $operation.name$
$paramRetType(operation.rettype)$ $operation.name$($paramDeclsOnlyOutByRef(params=operation.parameters)$);

>>

param_list(parameters) ::= <<>>

param(parameter) ::= <<>>

type_declarator(ctx, typedefs) ::= <<>>

struct_type(ctx, struct) ::= <<>>

union_type(ctx, union) ::= <<>>

enum_type(ctx, enum) ::= <<>>

/*!
 * Extra string templates.
 */
classAsyncHeader(operation) ::= <<
$if(!operation.oneway)$
/*!
 * @brief This abstract class defines the callbacks that RPCDDS will call in an asynchronous call.
 *        These callback has to be implemented in a derived class.
 */
class $operation.parent.name$_$operation.name$CallbackHandler
{
    public:
        /*!
         * This function is called when is received the reply from the server.
         */
        virtual void $operation.name$($paramDeclsByValue(params=[operation.outputparam, operation.rettypeparam])$) = 0;
        
        /*!
         * @brief This function is called when an exception occurs.
         *        This exception can be launched in the server's side or in the client's side.
         *
         * @param ex The exception that will be launched.
         */
        virtual void on_exception(const eprosima::rpcdds::exception::SystemException &ex) = 0;
        $if(operation.exceptions)$
        virtual void on_exception(const eprosima::rpcdds::exception::UserException &ex) = 0;
        $endif$
};

$endif$
>>

functionAsyncHeader(operation) ::= <<
$if(!operation.oneway)$
//! @brief Proxy asynchronous method for the operation $operation.name$
void $operation.name$_async($operation.parent.name$_$operation.name$CallbackHandler &obj$paramDeclsByValue(params=operation.inputparam, separatorInicial=", ")$);

$endif$
>>