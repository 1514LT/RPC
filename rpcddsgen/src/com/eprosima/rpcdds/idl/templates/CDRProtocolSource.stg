group CDRProtocolSource;

main(ctx, definitions) ::= <<
$fileHeader(file=[ctx.filename, "CDRProtocol.cxx"], description=["This source file contains the definition of the protocol used to create CDR messages."])$

#include "$ctx.filename$CDRProtocol.h"
#include "rpcdds/transports/ProxyTransport.h"
#include "rpcdds/transports/ServerTransport.h"
#include "rpcdds/exceptions/Exceptions.h"
#include "rpcdds/utils/Messages.h"
#include "fastcdr/exceptions/BadParamException.h"

using namespace eprosima::rpcdds;
using namespace ::protocol::cdr;
using namespace ::transport;
using namespace ::exception;

$ctx.filename$Protocol::$ctx.filename$Protocol() : ::protocol::$ctx.filename$Protocol(),
    serializeBuffer(), scdr(serializeBuffer)
{
}

$ctx.filename$Protocol::~$ctx.filename$Protocol()
{
}

bool $ctx.filename$Protocol::setTransport(Transport &transport)
{
    if(strcmp(transport.getType(), "RAW") == 0)
    {
    
        if(transport.getBehaviour() == SERVER_BEHAVIOUR)
        {
            // If this is a server transport, we set its callback
            eprosima::rpcdds::transport::ServerTransport &serverTransport = dynamic_cast<eprosima::rpcdds::transport::ServerTransport&>(transport);
            serverTransport.setCallback(&$ctx.filename$Protocol::worker);
        }
        
        Protocol::_setTransport(transport);
        
        return true;  
    }
    else
    {
        throw IncompatibleException("protocol and transport are incompatibles");
    }
    
    return false;
}

bool $ctx.filename$Protocol::activateInterface(const char* interfaceName)
{  
    return true;
}

void $ctx.filename$Protocol::worker(Protocol& protocol, void *&data, size_t dataLength, eprosima::rpcdds::transport::Endpoint *endpoint) 
{
    $ctx.filename$Protocol &_protocol = dynamic_cast<$ctx.filename$Protocol&>(protocol);
    size_t bufferUse = dataLength, cdrLength = 0;
    
    if(dataLength > 0 && endpoint != NULL)
    {
        do
        {
            if(((int32_t*&)data)[0] == 0x46434452)
            {
                cdrLength = ((int32_t*&)data)[1] + 8;

                if(bufferUse < cdrLength)
                {
                    data = realloc(data, cdrLength);

                    size_t dataToRead = cdrLength - bufferUse;
                    ServerTransport &serverTransport = dynamic_cast<ServerTransport&>(_protocol.getTransport());
                    int retCode = serverTransport.receive(&((char*&)data)[bufferUse], cdrLength, dataToRead, endpoint);

                    if(retCode >= 0)
                    {
                        bufferUse += dataToRead;

                        if(bufferUse < cdrLength)
                        {
                            // TODO error
                            printf("ERROR No se ha leido todos los datos necesarios\n");
                            return;
                        }
                    }
                    else
                    {
                        // TODO error
                        printf("ERROR Fallo leyendo\n");
                        return;
                    }
                }

                eprosima::FastBuffer dcdrBuffer((char*)data, bufferUse);
                eprosima::FastCdr dcdr(dcdrBuffer);

                dcdr.jump(8);
                std::string interface_name, operation_name;
                dcdr.deserialize(interface_name);
                dcdr.deserialize(operation_name);

                $if(first(ctx.interfaces))$
                    if(interface_name.compare("$first(ctx.interfaces).scopedname$") == 0)
                    {
                        if(_protocol._$first(ctx.interfaces).formatedScopedname$_impl != NULL)
                        {
                            $if(first(first(ctx.interfaces).operations))$
                                if(operation_name.compare("$first(first(ctx.interfaces).operations).name$") == 0)
                                {
                                    $operation_worker(operation=first(first(ctx.interfaces).operations))$
                                }
                            $rest(first(ctx.interfaces).operations) : {operation |
                                else if(operation_name.compare("$operation.name$") == 0)
                                {
                                    $operation_worker(operation=operation)$
                                }
                            }$
                            $endif$
                        }
                        else
                        {
                            // TODO Send system exception to client.
                        }
                    }
                $rest(ctx.interfaces) : {interface |
                    else if(interface_name.compare("$interface.scopedname$") == 0)
                    {
                        if(_protocol._$interface.formatedScopedname$_impl != NULL)
                        {
                            $if(first(interface.operations))$
                                if(operation_name.compare("$first(interface.operations).name$") == 0)
                                {
                                    $operation_worker(operation=first(interface.operations))$
                                }
                            $rest(interface.operations) : {operation |
                                else if(operation_name.compare("$operation.name$") == 0)
                                {
                                    $operation_worker(operation=operation)$
                                }
                            }$
                            $endif$
                        }
                        else
                        {
                            // TODO Send system exception to client.
                        }
                    }
                }$
                $endif$

                bufferUse -= cdrLength;
            }
            else
            {
                // TODO Print error.
                break;
            }
        }
        while((bufferUse > 0) & (memmove(data, data + cdrLength, bufferUse) != NULL));
    }
    else
    {
        //TODO Print error.
    }
}

$definitions; separator="\n"$

>>

module(ctx, module, definition_list) ::= <<
$definition_list$

>>

definition_list(definitions) ::= <<
$definitions; separator="\n"$
>>

interface(ctx, interface, export_list) ::= <<
$export_list$
>>

export_list(exports) ::= <<
$exports; separator="\n"$
>>

exception(ctx, exception) ::= <<>>

operation(ctx, operation, param_list) ::= <<
$if(ctx.client)$
$paramRetType(operation.rettype)$ $ctx.filename$Protocol::$operation.parent.formatedScopedname$_$operation.name$($paramDeclsOnlyOutByRef(params=operation.parameters)$)
{
    const char* const interface_name = "$operation.parent.scopedname$";
    const char* const operation_name = "$operation.name$";
    ReturnMessage retcode =CLIENT_INTERNAL_ERROR;
    // TODO In DDS the initialization is not necessary. But in CDR it is, for example a union with a char* (string) needs to be initialized to NULL.
    $varDecl(variable=operation.rettypeparam, create="yes")$
    
    eprosima::rpcdds::transport::ProxyTransport &proxyTransport = dynamic_cast<eprosima::rpcdds::transport::ProxyTransport&>(getTransport());
    
    scdr.jump(8);
    scdr.serialize(interface_name);
    scdr.serialize(operation_name);
    $operation.inputparam : {param |
    $serialization(obj=param)$
    };separator="\n"$
    
    char *buffer = serializeBuffer.getBuffer();
    ((int32_t*)buffer)[0] = 0x46434452;
    ((int32_t*)buffer)[1] = scdr.getSerializedDataLength() - 8;
    
    if(proxyTransport.connect())
    {
        // TODO Check if there is a problem.
        if(proxyTransport.send(buffer, scdr.getSerializedDataLength()))
        {
            scdr.reset();
            
            $if(!operation.oneway)$
            // TODO Cambiar
            size_t responseBufferSize = 8192, responseBufferUse = 0;
            char *response = (char*)calloc(responseBufferSize, sizeof(char));
            int retCode = proxyTransport.receive(response, responseBufferSize, responseBufferUse);
            
            if(retCode >= 0 && responseBufferUse >= 8)
            {
                if(((int32_t*)response)[0] == 0x46434452)
                {
                    size_t cdrLength = ((int32_t*)response)[1] + 8;
                    
                    if(responseBufferUse < cdrLength)
                    {   
                        // A buffer more big is needed.             
                        if(responseBufferSize < cdrLength)
                        {
                            response = (char*)realloc(response, cdrLength);
                            responseBufferSize = cdrLength;
                        }
                        
                        size_t dataToRead = cdrLength - responseBufferUse;
                        retCode = proxyTransport.receive(&response[responseBufferUse], responseBufferSize, dataToRead);
                        responseBufferUse += dataToRead;
                    }
                    
                    if(retCode >= 0 && responseBufferUse >= cdrLength)
                    {
                        eprosima::FastBuffer dcdrBuffer(response, responseBufferUse);
                        eprosima::FastCdr dcdr(dcdrBuffer);
                        
                        dcdr.jump(8);
                        std::string interface_name_r, operation_name_r;
                        dcdr.deserialize(interface_name_r);
                        dcdr.deserialize(operation_name_r);
                        
                        if(interface_name_r.compare(interface_name) == 0 &&
                            operation_name_r.compare(operation_name) == 0)
                        {
                            $[operation.outputparam, operation.rettypeparam] : {param |
                            $deserialization(obj=param)$
                            };separator="\n"$
                        }
                        else
                        {
                            // TODO Return error
                            printf("ERROR: Bad reply, reply to other operation\n");
                        }
                    }
                    else
                    {
                        // TODO error
                        printf("Error receiving the whole cdr message\n");
                    }
                }
                else
                {
                    // TODO Return error.
                    printf("ERROR: not received a cdr message\n");
                }
            }
            else
            {
                // TODO print error.
                printf("Error receiving the cdr message\n");
            }
            
            free(response);
            $endif$
        }
        else
        {
            scdr.reset();
            throw ClientInternalException("Error in client side");
        }
    }
    else
    {
        scdr.reset();
        throw ServerNotFoundException("Cannot connect to the server");
    }
    
    $if(operation.rettypeparam)$
    return $operation.rettypeparam.name$;
    $endif$
}
$endif$

>>

param_list(parameters) ::= <<>>

param(parameter) ::= <<>>

type_declarator(ctx, typedefs) ::= <<>>

struct_type(ctx, struct) ::= <<
void eprosima::rpcdds::protocol::cdr::serialize(eprosima::FastCdr &scdr, const $struct.scopedname$ &x)
{
    $struct.members:{$member_serialization(it)$}; separator="\n"$
}

void eprosima::rpcdds::protocol::cdr::deserialize(eprosima::FastCdr &dcdr, $struct.scopedname$ &x)
{  
    $struct.members:{$member_deserialization(it)$}; separator="\n"$
}

>>

union_type(ctx, union) ::= <<
void eprosima::rpcdds::protocol::cdr::serialize(eprosima::FastCdr &scdr, const $union.scopedname$ &x)
{ 
    scdr.serialize(x._d);
    
    switch(x._d)
    {
        $union.members:{$unionmember_case_selection_se(it)$}; separator="\n"$
    }
}

void eprosima::rpcdds::protocol::cdr::deserialize(eprosima::FastCdr &dcdr, $union.scopedname$ &x)
{
    dcdr.deserialize(x._d);

    switch(x._d)
    {
        $union.members:{$unionmember_case_selection_de(it)$}; separator="\n"$
    }
}
>>

enum_type(ctx, enum) ::= <<>>

/*************** Utils *****************/
operation_worker(operation) ::= <<
$operation.parameters : {param | $varDecl(variable=param, create=param.onlyOutput)$}; separator="\n"$
$varDecl(variable=operation.rettypeparam, create="yes")$

$operation.inputparam : {param | $if(!param.typecode.primitiveInArguments)$$varComplexInitialize(variable=param)$$\n$$endif$}$

$operation.inputparam : {param |
$deserialization(obj=param)$
};separator="\n"$

try
{
    $if(operation.rettypeparam)$$operation.rettypeparam.name$ = $endif$_protocol._$operation.parent.formatedScopedname$_impl->$operation.name$($extractParams(params=operation.parameters)$);
    
    $if(!operation.oneway)$
    eprosima::FastBuffer scdrBuffer;
    eprosima::FastCdr scdr(scdrBuffer);
    scdr.jump(8);
    scdr.serialize("$operation.parent.scopedname$");
    scdr.serialize("$operation.name$");
    
    $[operation.outputparam, operation.rettypeparam] : {param |
    $serialization(obj=param)$
    };separator="\n"$
    
    char *buffer = scdrBuffer.getBuffer();
    ((int32_t*)buffer)[0] = 0x46434452;
    ((int32_t*)buffer)[1] = scdr.getSerializedDataLength() - 8;

    dynamic_cast<ServerTransport&>(_protocol.getTransport()).sendReply(buffer, scdr.getSerializedDataLength(), endpoint);
    $endif$
}
$operation.exceptions : { exception |
catch(const $exception.scopedname$ &ex)
{
}
}; separator="\n"$
catch(const ServerInternalException &ex)
{
}

$[operation.parameters, operation.rettypeparam] : {param | $varDel(variable=param)$}; separator="\n"$

>>

member_serialization(member) ::= <<
$serialization(obj=member, prefix="x.")$
>>

member_deserialization(member) ::= <<
$deserialization(obj=member, prefix="x.")$
>>

unionmember_case_selection_se(member) ::= <<
$member.labels:{case $it$:}; separator="\n"$
$if(member.default)$
default:$\n$
$endif$
$serialization(obj=it, prefix="x._u.")$
break;
>>

unionmember_case_selection_de(member) ::= <<
$member.labels:{case $it$:}; separator="\n"$
$if(member.default)$
default:$\n$
$endif$
$deserialization(obj=it, prefix="x._u.")$
break;
>>

// TODO String type in RTI is char*, then we have to change the sizeFunction with strlen.
serialization(obj, prefix) ::= <<
$if(obj.typecode.maxsize)$
$if(obj.typecode.isType_d)$
if(strlen($prefix$$obj.name$) <= $obj.typecode.maxsize$)

$else$
if($prefix$$obj.name$.$sizeFunction.(obj.typecode.stType)$ <= $obj.typecode.maxsize$)
    
$endif$
$endif$
$if(obj.typecode.isType_e)$
$if(obj.typecode.contentTypeCode.primitive)$
scdr.serializeSequence($prefix$$obj.name$.get_contiguous_buffer(), $prefix$$obj.name$.length());
$else$
scdr.serialize((uint32_t)$prefix$$obj.name$.length());
$if(obj.typecode.contentTypeCode.isType_d)$
for(int count = 0; count < $prefix$$obj.name$.length(); ++count)
   scdr.serialize($prefix$$obj.name$.get_at(count));
$else$
for(int count = 0; count < $prefix$$obj.name$.length(); ++count)
   serialize(scdr, $prefix$$obj.name$.get_at(count));
$endif$
$endif$
$else$
$serializeFunction.(obj.typecode.stType)$$primitiveCastingType.(obj.typecode.stType)$$prefix$$obj.name$);
$endif$
$if(obj.typecode.maxsize)$
else
    throw eprosima::BadParamException(std::string("The maximum length was exceeded"));
$endif$
>>

deserialization(obj, prefix) ::= <<
$if(obj.typecode.isType_e)$
uint32_t $obj.name$SeqLength;
dcdr.deserialize($obj.name$SeqLength);
$prefix$$obj.name$.ensure_length($obj.name$SeqLength, $obj.name$SeqLength);
$if(obj.typecode.contentTypeCode.primitive)$
dcdr.deserializeArray($prefix$$obj.name$.get_contiguous_buffer(), $obj.name$SeqLength);
$else$
$if(obj.typecode.contentTypeCode.isType_d)$
for(int count = 0; count < $prefix$$obj.name$.length(); ++count)
   dcdr.deserialize($prefix$$obj.name$[count]);
$else$
for(int count = 0; count < $prefix$$obj.name$.length(); ++count)
   deserialize(dcdr, $prefix$$obj.name$[count]);
$endif$
$endif$
$else$
$deserializeFunction.(obj.typecode.stType)$$primitiveCastingType.(obj.typecode.stType)$$prefix$$obj.name$);
$endif$
>>

primitiveCasting(param) ::= <<
$primitiveCastingType.(param.typecode.stType)$
>>

serializeFunction ::= [
        "type_5":"scdr.serialize(",
        "type_6":"scdr.serialize(",
        "type_13":"scdr.serialize(",
        "type_1":"scdr.serialize(",
        "type_2":"scdr.serialize(",
        "type_11":"scdr.serialize(",
        "type_3":"scdr.serialize(",
        "type_4":"scdr.serialize(",
        "type_12":"scdr.serialize(",
        "type_8":"scdr.serialize(",
        "type_14":"scdr.serialize(",
        "type_7":"scdr.serialize(",
        "type_9":"scdr.serialize(",
        "type_f":"scdr.serialize(",
        "type_e":"scdr.serializeSequence(", // Not used because there is a condition to type_e
        "type_d":"scdr.serialize(",
        "type_15":"scdr.serialize(",
        "type_c":"scdr.serialize(",
        default: "serialize(scdr, " // not basic type.
]

deserializeFunction ::= [
        "type_5":"dcdr.deserialize(",
        "type_6":"dcdr.deserialize(",
        "type_13":"dcdr.deserialize(",
        "type_1":"dcdr.deserialize(",
        "type_2":"dcdr.deserialize(",
        "type_11":"dcdr.deserialize(",
        "type_3":"dcdr.deserialize(",
        "type_4":"dcdr.deserialize(",
        "type_12":"dcdr.deserialize(",
        "type_8":"dcdr.deserialize(",
        "type_14":"dcdr.deserialize(",
        "type_7":"dcdr.deserialize(",
        "type_9":"dcdr.deserialize(",
        "type_f":"dcdr.deserialize(",
        "type_e":"dcdr.deserializeSequence(", // Not used because there is a condition to type_e
        "type_d":"dcdr.deserialize(",
        "type_15":"dcdr.deserialize(",
        "type_c":"dcdr.deserialize(",
        default: "deserialize(dcdr, " // not basic type.
]

primitiveCastingType ::= [
        "type_11":"(int64_t&)", // Needed for RTI LongLong
        "type_12":"(uint64_t&)", // Needed for RTI ULongLong
        "type_c":"(uint32_t&)",
        default: // not casting
]

sizeFunction ::= [
        "type_e":"length()",
        "type_d":"length()",
        "type_15":"length()",
        default: // not basic type.
]
