group CDRProtocolSource;

main(ctx, definitions) ::= <<
$fileHeader(file=[ctx.filename, "CDRProtocol.cxx"], description=["This source file contains the definition of the protocol used to create CDR messages."])$

#include "$ctx.filename$CDRProtocol.h"
#include "rpcdds/transports/ProxyTransport.h"
#include "rpcdds/transports/ServerTransport.h"
#include "rpcdds/exceptions/Exceptions.h"
#include "rpcdds/utils/Messages.h"
#include "cpp/exceptions/BadParamException.h"

using namespace eprosima::rpcdds;
using namespace ::protocol::cdr;
using namespace ::transport;
using namespace ::exception;

$ctx.filename$Protocol::$ctx.filename$Protocol() : ::protocol::$ctx.filename$Protocol(),
    serializeBuffer(), scdr(serializeBuffer)
{
}

$ctx.filename$Protocol::~$ctx.filename$Protocol()
{
}

bool $ctx.filename$Protocol::setTransport(Transport &transport)
{
    if(strcmp(transport.getType(), "RAW") == 0)
    {
    
        if(transport.getBehaviour() == SERVER_BEHAVIOUR)
        {
            // If this is a server transport, we set its callback
            eprosima::rpcdds::transport::ServerTransport &serverTransport = dynamic_cast<eprosima::rpcdds::transport::ServerTransport&>(transport);
            serverTransport.setCallback(&$ctx.filename$Protocol::worker);
        }
        
        Protocol::_setTransport(transport);
        
        return true;  
    }
    else
    {
        throw IncompatibleException("protocol and transport are incompatibles");
    }
    
    return false;
}

bool $ctx.filename$Protocol::activateInterface(const char* interfaceName)
{  
    return true;
}

void $ctx.filename$Protocol::worker(Protocol& protocol, void *&data, size_t dataLength, eprosima::rpcdds::transport::Endpoint *endpoint) 
{
    $ctx.filename$Protocol &_protocol = dynamic_cast<$ctx.filename$Protocol&>(protocol);
    size_t bufferUse = dataLength;
    
    if(dataLength > 0 && endpoint != NULL)
    {
        if(((int32_t*&)data)[0] == 0x46434452)
        {
            size_t cdrLength = ((int32_t*&)data)[1] + 8;
            
            if(bufferUse < cdrLength)
            {
                data = realloc(data, cdrLength);
                
                size_t dataToRead = cdrLength - bufferUse;
                ServerTransport &serverTransport = dynamic_cast<ServerTransport&>(_protocol.getTransport());
                int retCode = serverTransport.receive(&((char*&)data)[bufferUse], cdrLength, dataToRead, endpoint);
                
                if(retCode >= 0)
                {
                    bufferUse += dataToRead;
                    
                    if(bufferUse < cdrLength)
                    {
                        // TODO error
                        printf("ERROR No se ha leido todos los datos necesarios\n");
                        return;
                    }
                }
                else
                {
                    // TODO error
                    printf("ERROR Fallo leyendo\n");
                    return;
                }
            }
            
            eProsima::FastBuffer dcdrBuffer((char*)data, bufferUse);
            eProsima::FastCdr dcdr(dcdrBuffer);
            
            dcdr.jump(8);
            std::string interface_name, operation_name;
            dcdr.deserialize(interface_name);
            dcdr.deserialize(operation_name);
            
            $if(first(ctx.interfaces))$
            if(interface_name.compare("$first(ctx.interfaces).scopedname$") == 0)
            {
                if(_protocol._$first(ctx.interfaces).formatedScopedname$_impl != NULL)
                {
                    $if(first(first(ctx.interfaces).operations))$
                    if(operation_name.compare("$first(first(ctx.interfaces).operations).name$") == 0)
                    {
                        $operation_worker(operation=first(first(ctx.interfaces).operations))$
                    }
                    $rest(first(ctx.interfaces).operations) : {operation |
                    else if(operation_name.compare("$operation.name$") == 0)
                    {
                        $operation_worker(operation=operation)$
                    }
                    }$
                    $endif$
                }
                else
                {
                    // TODO Send system exception to client.
                }
            }
            $rest(ctx.interfaces) : {interface |
            else if(interface_name.compare("$interface.scopedname$") == 0)
            {
                if(_protocol._$interface.formatedScopedname$_impl != NULL)
                {
                    $if(first(interface.operations))$
                    if(operation_name.compare("$first(interface.operations).name$") == 0)
                    {
                        $operation_worker(operation=first(interface.operations))$
                    }
                    $rest(interface.operations) : {operation |
                    else if(operation_name.compare("$operation.name$") == 0)
                    {
                        $operation_worker(operation=operation)$
                    }
                    }$
                    $endif$
                }
                else
                {
                    // TODO Send system exception to client.
                }
            }
            }$
            $endif$
        }
        else
        {
            // TODO Print error.
        }
    }
    else
    {
        //TODO Print error.
    }
}

$definitions; separator="\n"$

>>

module(ctx, module, definition_list) ::= <<
$definition_list$

>>

definition_list(definitions) ::= <<
$definitions; separator="\n"$
>>

interface(ctx, interface, export_list) ::= <<
$export_list$
>>

export_list(exports) ::= <<
$exports; separator="\n"$
>>

exception(ctx, exception) ::= <<>>

operation(ctx, operation, param_list) ::= <<
$if(ctx.client)$
$paramRetType(operation.rettype)$ $ctx.filename$Protocol::$operation.parent.formatedScopedname$_$operation.name$($paramDeclsOnlyOutByRef(params=operation.parameters)$)
{
    const char* const interface_name = "$operation.parent.scopedname$";
    const char* const operation_name = "$operation.name$";
    ReturnMessage retcode =CLIENT_INTERNAL_ERROR;
    $varDecl(variable=operation.rettypeparam)$
    
    eprosima::rpcdds::transport::ProxyTransport &proxyTransport = dynamic_cast<eprosima::rpcdds::transport::ProxyTransport&>(getTransport());
    
    scdr.jump(8);
    scdr.serialize(interface_name);
    scdr.serialize(operation_name);
    $operation.inputparam : {param |
    $serialization(obj=param)$
    };separator="\n"$
    
    char *buffer = serializeBuffer.getBuffer();
    ((int32_t*)buffer)[0] = 0x46434452;
    ((int32_t*)buffer)[1] = scdr.getSerializedDataLength() - 8;
    
    proxyTransport.connect();
    
    // TODO Check if there is a problem.
    proxyTransport.send(buffer, scdr.getSerializedDataLength());
    scdr.reset();
    
    $if(!operation.oneway)$
    // TODO Cambiar
    size_t responseBufferSize = 8192, responseBufferUse = 0;
    char *response = (char*)calloc(responseBufferSize, sizeof(char));
    int retCode = proxyTransport.receive(response, responseBufferSize, responseBufferUse);
    
    if(retCode >= 0 && responseBufferUse >= 8)
    {
        if(((int32_t*)response)[0] == 0x46434452)
        {
            size_t cdrLength = ((int32_t*)response)[1] + 8;
            
            if(responseBufferUse < cdrLength)
            {   
                // A buffer more big is needed.             
                if(responseBufferSize < cdrLength)
                {
                    response = (char*)realloc(response, cdrLength);
                    responseBufferSize = cdrLength;
                }
                
                size_t dataToRead = cdrLength - responseBufferUse;
                retCode = proxyTransport.receive(&response[responseBufferUse], responseBufferSize, dataToRead);
                responseBufferUse += dataToRead;
            }
            
            if(retCode > 0 && responseBufferUse >= cdrLength)
            {
                eProsima::FastBuffer dcdrBuffer(response, responseBufferUse);
                eProsima::FastCdr dcdr(dcdrBuffer);
                
                dcdr.jump(8);
                std::string interface_name_r, operation_name_r;
                dcdr.deserialize(interface_name_r);
                dcdr.deserialize(operation_name_r);
                
                if(interface_name_r.compare(interface_name) == 0 &&
                    operation_name_r.compare(operation_name) == 0)
                {
                    $[operation.outputparam, operation.rettypeparam] : {param |
                    $deserialization(obj=param)$
                    };separator="\n"$
                }
                else
                {
                    // TODO Return error
                }
            }
            else
            {
                // TODO error
            }
        }
        else
        {
            // TODO Return error.
        }
    }
    else
    {
        // TODO print error.
    }
    
    free(response);
    $endif$
    
    $if(operation.rettypeparam)$
    return $operation.rettypeparam.name$;
    $endif$
}
$endif$

>>

param_list(parameters) ::= <<>>

param(parameter) ::= <<>>

type_declarator(ctx, typedefs) ::= <<>>

struct_type(ctx, struct) ::= <<
void eprosima::rpcdds::protocol::cdr::serialize(eProsima::FastCdr &scdr, const $struct.scopedname$ &x)
{
    $struct.members:{$member_serialization(it)$}; separator="\n"$
}

void eprosima::rpcdds::protocol::cdr::deserialize(eProsima::FastCdr &dcdr, $struct.scopedname$ &x)
{  
    $struct.members:{$member_deserialization(it)$}; separator="\n"$
}

>>

union_type(ctx, union) ::= <<>>

enum_type(ctx, enum) ::= <<>>

/*************** Utils *****************/
operation_worker(operation) ::= <<
$operation.parameters : {param | $varDecl(variable=param, create=param.onlyOutput)$}; separator="\n"$
$varDecl(variable=operation.rettypeparam, create="yes")$

$operation.inoutputparam : {param | $if(!param.typecode.primitiveInArguments)$$varComplexInitialize(variable=param)$$\n$$endif$}$

$operation.inputparam : {param |
$deserialization(obj=param)$
};separator="\n"$

try
{
    $if(operation.rettypeparam)$$operation.rettypeparam.name$ = $endif$_protocol._$operation.parent.formatedScopedname$_impl->$operation.name$($extractParams(params=operation.parameters)$);
    
    $if(!operation.oneway)$
    eProsima::FastBuffer scdrBuffer;
    eProsima::FastCdr scdr(scdrBuffer);
    scdr.jump(8);
    scdr.serialize("$operation.parent.scopedname$");
    scdr.serialize("$operation.name$");
    
    $[operation.outputparam, operation.rettypeparam] : {param |
    $serialization(obj=param)$
    };separator="\n"$
    
    char *buffer = scdrBuffer.getBuffer();
    ((int32_t*)buffer)[0] = 0x46434452;
    ((int32_t*)buffer)[1] = scdr.getSerializedDataLength() - 8;

    dynamic_cast<ServerTransport&>(_protocol.getTransport()).sendReply(buffer, scdr.getSerializedDataLength(), endpoint);
    $endif$
}
$operation.exceptions : { exception |
catch(const $exception.scopedname$ &ex)
{
}
}; separator="\n"$
catch(const ServerInternalException &ex)
{
}

$[operation.outputparam, operation.rettypeparam] : {param | $varDel(variable=param)$}; separator="\n"$

>>

member_serialization(member) ::= <<
$serialization(obj=member, prefix="x.")$
>>

member_deserialization(member) ::= <<
$deserialization(obj=member, prefix="x.")$
>>

serialization(obj, prefix) ::= <<
$if(obj.typecode.maxsize)$
if($prefix$$obj.name$.$sizeFunction.(obj.typecode.stType)$ <= $obj.typecode.maxsize$)
    
$endif$
$if(obj.typecode.isType_e)$
scdr.serializeSequence($prefix$$obj.name$.get_contiguous_buffer(), $prefix$$obj.name$.length());
$else$
$serializeFunction.(obj.typecode.stType)$$primitiveCastingType.(obj.typecode.stType)$$prefix$$obj.name$);
$endif$
$if(obj.typecode.maxsize)$
else
    throw eProsima::BadParamException(std::string("The maximum length was exceeded"));
$endif$
>>

deserialization(obj, prefix) ::= <<
$if(obj.typecode.isType_e)$
uint32_t $obj.name$SeqLength;
dcdr.deserialize($obj.name$SeqLength);
$prefix$$obj.name$.ensure_length($obj.name$SeqLength, $obj.name$SeqLength);
dcdr.deserializeArray($prefix$$obj.name$.get_contiguous_buffer(), $obj.name$SeqLength);
$else$
$deserializeFunction.(obj.typecode.stType)$$primitiveCastingType.(obj.typecode.stType)$$prefix$$obj.name$);
$endif$
>>

primitiveCasting(param) ::= <<
$primitiveCastingType.(param.typecode.stType)$
>>

serializeFunction ::= [
        "type_5":"scdr.serialize(",
        "type_6":"scdr.serialize(",
        "type_13":"scdr.serialize(",
        "type_1":"scdr.serialize(",
        "type_2":"scdr.serialize(",
        "type_11":"scdr.serialize(",
        "type_3":"scdr.serialize(",
        "type_4":"scdr.serialize(",
        "type_12":"scdr.serialize(",
        "type_8":"scdr.serialize(",
        "type_14":"scdr.serialize(",
        "type_7":"scdr.serialize(",
        "type_9":"scdr.serialize(",
        "type_f":"scdr.serialize(",
        "type_e":"scdr.serializeSequence(", // Not used because there is a condition to type_e
        "type_d":"scdr.serialize(",
        "type_15":"scdr.serialize(",
        "type_c":"scdr.serialize(",
        default: "serialize(scdr, " // not basic type.
]

deserializeFunction ::= [
        "type_5":"dcdr.deserialize(",
        "type_6":"dcdr.deserialize(",
        "type_13":"dcdr.deserialize(",
        "type_1":"dcdr.deserialize(",
        "type_2":"dcdr.deserialize(",
        "type_11":"dcdr.deserialize(",
        "type_3":"dcdr.deserialize(",
        "type_4":"dcdr.deserialize(",
        "type_12":"dcdr.deserialize(",
        "type_8":"dcdr.deserialize(",
        "type_14":"dcdr.deserialize(",
        "type_7":"dcdr.deserialize(",
        "type_9":"dcdr.deserialize(",
        "type_f":"dcdr.deserialize(",
        "type_e":"dcdr.deserializeSequence(", // Not used because there is a condition to type_e
        "type_d":"dcdr.deserialize(",
        "type_15":"dcdr.deserialize(",
        "type_c":"dcdr.deserialize(",
        default: "deserialize(dcdr, " // not basic type.
]

primitiveCastingType ::= [
        "type_11":"(int64_t&)", // Needed for RTI LongLong
        "type_12":"(uint64_t&)", // Needed for RTI ULongLong
        "type_c":"(uint32_t&)",
        default: // not casting
]

sizeFunction ::= [
        "type_e":"length()",
        "type_d":"length()",
        "type_15":"length()",
        default: // not basic type.
]
