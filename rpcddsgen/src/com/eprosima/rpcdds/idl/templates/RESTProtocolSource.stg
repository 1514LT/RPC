group RESTProtocolSource;

main(ctx, definitions) ::= <<
$fileHeader(file=[ctx.filename, "RESTProtocol.cxx"], description=["This source file contains the definition of the protocol used to create REST messages."])$

#include <string>
#include "$ctx.filename$RESTProtocol.h"
#include "transports/Transport.h"
#include "exceptions/Exceptions.h"
#include "transports/TCPProxyTransport.h"

using namespace std;
using namespace eprosima::httpser;
using namespace eprosima::rpcdds;
using namespace eprosima::rpcdds::protocol::rest;
using namespace eprosima::rpcdds::transport;
using namespace eprosima::rpcdds::exception;

$ctx.filename$Protocol::$ctx.filename$Protocol() {}

$ctx.filename$Protocol::~$ctx.filename$Protocol() {}

bool $ctx.filename$Protocol::setTransport(Transport &transport)
{    
    if(strcmp(transport.getType(), "RAW") != 0)
    {
        throw IncompatibleException("protocol and transport are incompatibles");
    }
    
    if(transport.getBehaviour() == SERVER_BEHAVIOUR) {
        // If this is a server transport, we set its callback
        eprosima::rpcdds::transport::TCPServerTransport &serverTransport = dynamic_cast<eprosima::rpcdds::transport::TCPServerTransport&>( transport );
        serverTransport.setCallback(&$ctx.filename$Protocol::worker);
    }
        
    _setTransport(transport);
        
    return true;
}

bool $ctx.filename$Protocol::activateInterface(const char* interfaceName)
{
    return true;
}

void $ctx.filename$Protocol::worker(Protocol& protocol, eprosima::rpcdds::transport::ServerTransport &transport, void* connection) {
    boost::shared_ptr<eprosima::rpcdds::transport::connection> conn = *(boost::shared_ptr<
            eprosima::rpcdds::transport::connection>*) (connection);
    boost::system::error_code ec = boost::system::error_code();
    boost::asio::ip::tcp::socket &socket = *(conn->socket_);
    boost::asio::socket_base::non_blocking_io make_non_blocking(true);
    socket.io_control(make_non_blocking);

    std::cout << "Thread #" << boost::this_thread::get_id() << std::endl;

    // TODO : El tamaño esta fijo estáticamente. Habrá que investigarlo.
    char* buffer_ = (char*)malloc(8192);

    // TODO : Comprobar return.
    boost::asio::read(socket, boost::asio::buffer(buffer_, 8192), ec);

    // TODO : Call the protocol
    eprosima::rpcdds::protocol::rest::$ctx.filename$Protocol &restProtocol = dynamic_cast<eprosima::rpcdds::protocol::rest::$ctx.filename$Protocol&>( protocol );
    char* responseBuffer = restProtocol.proccessRequest(buffer_);
    size_t bytes_sent = boost::asio::write(socket, boost::asio::buffer(responseBuffer, strlen(responseBuffer)+1), boost::asio::transfer_all(), ec);
    if(bytes_sent == 0) {
        cout << "Error sending response." << endl;
    }

    // XXX close?

    free(buffer_);
    if(responseBuffer)
        free(responseBuffer);

    socket.get_io_service().run();
}

$definitions; separator="\n"$

// Server
char* $ctx.filename$Protocol::proccessRequest(char* httpRequest) {
    // Not found error serialization
    char* http404Response = (char*)malloc(1024);
    memset(http404Response, 0, 1024);
    FastBuffer fastBuffer404(http404Response, 1024);
    HTTPSerializer* http404Serializer = new HTTPSerializer(fastBuffer404);
    string responseVersion = "HTTP/1.1";
    HTTPVersion httpResponseVersion = HTTPVersion::HTTPVersionResponse(responseVersion);
    http404Serializer->serialize(httpResponseVersion);
    string code = "404";
    string text = "Not found";
    HTTPResponseCode httpResponseCode(code, text);
    http404Serializer->serialize(httpResponseCode);    
    //

    // HTTP Request deserialization
    HTTPMethod httpMethod;
    string baseUri = "$ctx.resourceBaseUri$"; // We give the serializator our base uri
    string path = "";
    HTTPUri httpUri = HTTPUri(baseUri, path);
    HTTPParameters httpParams;

    FastBuffer requestFastBuffer(httpRequest, 8192);
    HTTPSerializer* httpSerializer = new HTTPSerializer(requestFastBuffer);
    httpSerializer->deserialize(httpMethod);
    httpSerializer->deserialize(httpUri);
    path = httpUri.getPath();
    httpSerializer->deserialize(httpParams);
    httpSerializer->reset();
    //
    
    $ctx.deserializeCode$
    
    return http404Response;
}
>>

module(ctx, module, definition_list) ::= <<
$definition_list$

>>

definition_list(definitions) ::= <<
$definitions; separator="\n"$
>>

interface(ctx, interface, export_list) ::= <<
$export_list$
>>

export_list(exports) ::= <<
$exports; separator="\n"$
>>

exception(ctx, exception) ::= <<
void $exception.name$Utils::setTypeData(const $exception.name$ &ex, $exception.name$_t &instance)
{
    $exception.members : { member |instance.$member.name$ = ex.$member.name$;}; separator="\n"$
}

void $exception.name$Utils::extractTypeData($exception.name$ &ex, $exception.name$_t &data)
{
    $exception.members : { member |ex.$member.name$ = data.$member.name$$if(member.typecode.string)$$stringPointer()$$endif$;}; separator="\n"$
}

>>

operation(ctx, operation, param_list) ::= <<
$if(operation.parent.pathHasBrackets)$
string $ctx.filename$Protocol::expandPath_$operation.name$(string path, $first(operation.parameters).name$ $first(operation.parameters).name$)
{
    stringstream stream;
    string expandedPath = "";
    string pathSegment = "";
    char *p = strtok(strdup(path.c_str()), "/");

    $expandPathSegment(param=first(operation.parameters))$

    if(expandedPath.size() == 0)
        expandedPath = path;
    return expandedPath;
}

$endif$
$paramRetType(operation.rettype)$ $ctx.filename$Protocol::$operation.parent.formatedScopedname$_$operation.name$($paramDeclsOnlyOutByRef(params=operation.parameters)$)
{
     stringstream stream;
     string mediaType;
     eprosima::rpcdds::transport::ProxyTransport &proxyTransport = dynamic_cast<eprosima::rpcdds::transport::ProxyTransport&>( getTransport() );
     // XXX TODO if NULL -> error
     
     // Resource Base URI = $ctx.resourceBaseUri$
     // Path = $operation.parent.path$
     // Method = $operation.method$
     // Body Parameter = $operation.body$

     // Serialize HTTP message
     char* httpRequestBuffer = (char*)malloc(8192);
     memset(httpRequestBuffer, 0, 8192);
          
     FastBuffer fastBuffer(httpRequestBuffer, 8192);
     HTTPSerializer* httpSerializer = new HTTPSerializer(fastBuffer);

     HTTPMethod method(HTTP_$operation.method$);
     httpSerializer->serialize(method);
     
     string baseURI = "$ctx.resourceBaseUri$";
     string pathURI = "$operation.parent.path$";
     $if(operation.parent.pathHasBrackets)$
     pathURI = expandPath_$operation.name$(pathURI, $first(operation.parameters).name$);
     $endif$
     HTTPUri httpUri(baseURI, pathURI);
     httpSerializer->serialize(httpUri);
     
     $if(operation.parent.pathHasBrackets)$
        $serializeHTTPParams(params=rest(operation.parameters))$
     $else$
        $serializeHTTPParams(params=operation.parameters)$
     $endif$
     
     string stringVersionRequest = "HTTP/1.1";
     HTTPVersion versionRequest = HTTPVersion::HTTPVersionRequest(stringVersionRequest);
     httpSerializer->serialize(versionRequest);
     
     $serializeHTTPBodyParams(params=operation.parameters)$

    // HTTP connection
    proxyTransport.connect();
    proxyTransport.send(httpRequestBuffer);
    char* httpResponseBuffer = proxyTransport.receive();

    // Deserialize HTTP response
    FastBuffer fastBufferResponse(httpResponseBuffer, 8192);
    HTTPSerializer* httpResponseSerializer = new HTTPSerializer(fastBufferResponse);

    HTTPVersion versionResponse;
    httpResponseSerializer->deserialize(versionResponse);
    HTTPResponseCode httpResponseCode;
    httpResponseSerializer->deserialize(httpResponseCode);

    httpResponseSerializer->deserialize(httpData);
    data = httpData.getData();
    
    $paramRetType(operation.rettype)$ retType;
    $paramRetType(operation.rettype)$_initialize(&retType);
    
    discriminator = 0;
    mediaType = httpData.getMediaType();
    if(mediaType.find("xml") != string::npos) {
        discriminator = 1;
    } 
    if(mediaType.find("json") != string::npos) {
        discriminator = 2;
    }
    
    retType._d = discriminator;
    switch(discriminator) {
    $operation.rettype.members : {member | case $first(member.labels)$:
    retType._u.$member.name$.$first(member.typecode.members).name$ = httpResponseCode.getStatusCode();
    $if(rest(member.typecode.members))$
    retType._u.$member.name$.$first(rest(member.typecode.members)).name$ = strdup(data.c_str());
    $endif$
    break;
    }$
    }
              
    return retType;
}

$if(operation.parent.pathHasBrackets)$
void $ctx.filename$Protocol::deserializePath_$operation.name$(string actualPath, $first(operation.parameters).name$& $first(operation.parameters).name$)
{
    string templatePath = "$operation.parent.path$";
    stringstream stream;
    unsigned int prevTemplatePos = 0;
    unsigned int prevActualPos = 0;
    unsigned int templatePos = 0;
    unsigned int actualPos = 0;
    string templatePathSegment;
    string actualPathSegment;
    
    $deserializePathSegment(param=first(operation.parameters))$
}
$endif$

char* $ctx.filename$Protocol::deserialize_$operation.parent.formatedScopedname$_$operation.name$(HTTPSerializer* httpSerializer) {
    string mediaType;
    stringstream stream;
    HTTPMethod httpMethod;
    string baseUri = "$ctx.resourceBaseUri$"; // We give the serializator our base uri
    string path = "";
    HTTPUri httpUri = HTTPUri(baseUri, path);
    HTTPParameters httpParams;
    HTTPVersion httpRequestVersion;
    HTTPData httpData;

    httpSerializer->deserialize(httpMethod);
    httpSerializer->deserialize(httpUri);
    httpSerializer->deserialize(httpParams);
    httpSerializer->deserialize(httpRequestVersion);
    httpSerializer->deserialize(httpData);
    
    $if(operation.parent.pathHasBrackets)$
    $first(operation.parameters).name$ $first(operation.parameters).name$;
    deserializePath_$operation.name$(httpUri.get_data(), $first(operation.parameters).name$);
    $deserializeHTTPParams(params=rest(operation.parameters))$
    $else$
    $deserializeHTTPParams(params=operation.parameters)$
    $endif$
    
    $deserializeHTTPBodyParams(params=operation.parameters)$
    
    $paramRetType(operation.rettype)$ $paramRetType(operation.rettype)$ = _$operation.parent.formatedScopedname$_impl->$operation.name$($implCallParams(params = operation.parameters)$);
    
    char* httpResponse = (char*) malloc(8192);
    memset(httpResponse, 0, 8192);
    $serializeServerResponse(rettype=operation.rettype)$    
    return httpResponse;
}
>>

implCallParams(params) ::= <<
$if(first(params))$ $if(first(params).parent.parent.pathHasBrackets)$ $first(operation.parameters).name$ $rest(params) : { param |, $param.name$ }$ $else$ $params : { param |$param.name$}; separator=", "$ $endif$ $endif$
>>

serializeServerResponse(rettype) ::= <<
FastBuffer responseFastBuffer(httpResponse, 8192); 
HTTPSerializer* httpResponseSerializer = new HTTPSerializer(responseFastBuffer);
string stringVersionResponse = "HTTP/1.1";
HTTPVersion versionResponse = HTTPVersion::HTTPVersionResponse(stringVersionResponse);
httpResponseSerializer->serialize(versionResponse);

int httpResponseStatus = 0;
string responseData = "";
switch($rettype.name$._d) {
$rettype.members : {member |    case $first(member.labels)$:
    httpResponseStatus = $rettype.name$._u.$member.name$.status;
$first(rest(member.typecode.members)) : {member2 |      responseData = $rettype.name$._u.$member.name$.$member2.name$; }$
    break;
}$}
stream << httpResponseStatus;
string code = stream.str();
string status = "";
HTTPResponseCode httpResponseCode(code, status);
stream.str(std::string());
httpResponseSerializer->serialize(httpResponseCode);
if(responseData.size()>0) {
    stream << responseData.length();
    string size = stream.str();
    if($rettype.name$._d == 1)
        mediaType = "application/xml";
    else if($rettype.name$._d == 2)
        mediaType = "application/json";
    HTTPData httpData(size, mediaType, responseData);
    stream.str(std::string());
}

>>

deserializePathSegment(param) ::= <<
    $param.typecode.members : {member |
    // Deserialize $member.name$
    while (templatePos != string::npos && actualPos != string::npos) {
        templatePos = templatePath.find("/", prevTemplatePos);
        actualPos = actualPath.find("/", prevActualPos);
        templatePathSegment = templatePath.substr(prevTemplatePos, templatePos - prevTemplatePos);
        actualPathSegment = actualPath.substr(prevActualPos, actualPos - prevActualPos);
        prevTemplatePos = templatePos + 1;
        prevActualPos = actualPos + 1;
        if(templatePathSegment.at(0) == '{' && templatePathSegment.at(templatePathSegment.size() - 1) == '}') {
            stream << actualPathSegment;
            stream $ctx.sersym$ $param.name$.$member.name$;
            stream.str(std::string());
            break;
        }
    }
    }$
>>

expandPathSegment(param) ::= <<
    $param.typecode.members : {member |
    // Expand $member.name$
    while (p) {
        pathSegment = p;
        p = strtok(NULL, "/");
        if(pathSegment.at(0) == '{' && pathSegment.at(pathSegment.size() - 1) == '}')
            break;
        expandedPath += pathSegment + "/";
    }
    stream << $param.name$.$member.name$;
    expandedPath += stream.str() + "/";
    stream.str(std::string());
    }$
>>

deserializeHTTPParams(params) ::= <<
$if(params)$
HTTPParam httpParam;
$params : {param |$if(!param.bodyParam)$$varDecl(variable=param)$$endif$
}$
for(vector<HTTPParam>::iterator it = httpParams.get_params().begin(); it != httpParams.get_params().end(); ++it) {
    httpParam = *it;
$endif$
$params : {param |
$if(!param.bodyParam)$
    // Deserialize $param.name$
    if(httpParam.getName().compare("$param.name$") == 0) {
        $if(param.typecode.string)$
        $param.name$ = (char*)malloc(sizeof(char)*(httpParam.getValue().size()+1));
        memset($param.name$, 0, sizeof(char)*(httpParam.getValue().size()+1));$endif$
        stream << httpParam.getValue();
        stream $ctx.sersym$ $param.name$;
        stream.str(std::string());
    }
$endif$
}$
$if(params)$
}
$endif$
>>

serializeHTTPParams(params) ::= <<
$if(params)$
HTTPParameters httpParameters;
string paramName;
string paramValue;
HTTPParam httpParam;
$endif$

$params : {param |
$if(!param.bodyParam)$
paramName = "$param.name$";
stream << $param.name$;
paramValue = stream.str();
stream.str(std::string());
httpParam = HTTPParam(paramName, paramValue);
httpParameters.addParam(httpParam);

$endif$
}$       
$if(params)$httpSerializer->serialize(httpParameters);
$endif$
>>

serializeHTTPBodyParams(params) ::= <<
HTTPData httpData(baseURI);
string data = "";
int discriminator = 0;
$params : {param|$if(param.bodyParam)$// Serializing body parameter $param.name$
discriminator = $param.name$._d;
switch(discriminator) {
$param.typecode.members : {member | case $first(member.labels)$:
    data = $param.name$._u.$member.name$;
    break;
    }$
}
if(data.size() > 0) {
	stream << data.size();
    string size = stream.str();
    if(discriminator == 1)
        mediaType = "application/xml";
    else if(discriminator == 2)
        mediaType = "application/json";
    httpData = HTTPData(baseURI, size, mediaType, data);
    stream.str(std::string());
    httpSerializer->serialize(httpData);
}$endif$}$
if(data.size() == 0) {
    httpSerializer->serialize(httpData);
}
>>

deserializeHTTPBodyParams(params) ::= <<
$params : {param | $if(param.bodyParam)$// Deserializing body parameter $param.name$
$param.name$ $param.name$;
mediaType = httpData.getMediaType();
int discriminator = 0;
if(mediaType.find("xml") != string::npos)
    discriminator = 1;
if(mediaType.find("json") != string::npos)
    discriminator = 2;
    
$param.name$._d = discriminator;
switch(discriminator) {
$param.typecode.members : {member | case $first(member.labels)$:
$param.name$._u.$member.name$ = strdup(httpData.getData().c_str());
break;
}$}
$endif$
}$
>>

param_list(parameters) ::= <<>>

param(parameter) ::= <<>>

type_declarator(ctx, typedefs) ::= <<>>

struct_type(ctx, struct) ::= <<>>

union_type(ctx, union) ::= <<>>

enum_type(ctx, enum) ::= <<>>


/*!
 * Extra string templates. Utils.
 */
createDataHelper(param, dataname, isRequest) ::= <<
$if(param.typecode.array)$
$memberComplexExtract(member=param, dataname=dataname)$
$else$
$dataname$.$param.name$ = $if(isRequest)$$if(param.typecode.string)$$charConstCasting()$$endif$$endif$$param.name$;
$endif$
>>

extractDataHelper(param, dataname, isReply) ::= <<
$if(isReply)$
$if(param.input)$
$if(param.typecode.primitiveInArguments)$
$if(param.typecode.string)$
if($param.name$ != NULL)
    free($param.name$);
$endif$
$else$
$varComplexDel(variable=param)$
$endif$
$endif$
$if(param.typecode.array)$
$memberComplexCopy(member=param, dataname=dataname)$
$else$
$param.name$ = $dataname$.$param.name$$if(param.typecode.string)$$stringPointer()$$endif$;
$endif$
$else$
$if(param.output)$
$if(param.typecode.primitiveInArguments)$
$if(param.typecode.string)$
$param.name$ = strdup($dataname$.$param.name$);
$else$
$param.name$ = $dataname$.$param.name$;
$endif$
$else$
$memberComplexCopy(member=param, dataname=dataname)$
$endif$
$else$
$if(param.typecode.array)$
$memberComplexCopy(member=param, dataname=dataname)$
$else$
$param.name$ = $dataname$.$param.name$$if(param.typecode.string)$$stringPointer()$$endif$;
$endif$
$endif$
$endif$
>>

createExceptionUtil(operation, exception) ::= <<
void $operation.parent.name$_$operation.name$_$exception.name$Utils::setTypeData(const $exception.scopedname$ &ex, $operation.parent.name$_$operation.name$_$exception.name$_t &instance)
{
    $exception.members : { member |instance.$member.name$ = ex.$member.name$;}; separator="\n"$
}

void $operation.parent.name$_$operation.name$_$exception.name$Utils::extractTypeData($exception.scopedname$ &ex, $operation.parent.name$_$operation.name$_$exception.name$_t &data)
{
    $exception.members : { member |ex.$member.name$ = data.$member.name$$if(member.typecode.string)$$stringPointer()$$endif$;}; separator="\n"$
}


>>
