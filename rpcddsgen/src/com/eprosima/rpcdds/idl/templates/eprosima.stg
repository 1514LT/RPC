group eprosima;

paramTypeByValue(typecode) ::= <<
$if(typecode.primitive)$
$if(typecode.isType_d)$
const $typecode.cppTypename$&
$else$
$typecode.cppTypename$
$endif$
$else$
const $typecode.cppTypename$&
$endif$
>>

varDecl(variable, create) ::= <<
$if(variable)$
$if(variable.typecode.primitive)$
$variable.typecode.cppTypename$  $variable.name$ = $variable.typecode.initialValue$;
$else$
$variable.typecode.cppTypename$  $variable.name$;
$endif$
$endif$
>>

varDel(variable) ::= <<>>

getTypenameOperation(operation, suffix, varname) ::= <<
$varname$ = $operation.parent.scopedname$Plugin::$operation.name$$suffix$Plugin::get_typename();
>>

registerTypenameOperationAndCheck(operation, suffix, varname) ::= <<
!$operation.parent.scopedname$Plugin::$operation.name$$suffix$Plugin::register_type(m_ddsTransport->getParticipant(), $varname$)
>>

createDataCallback(operation, suffix) ::= <<
(::transport::dds::Transport::Create_data)$operation.parent.scopedname$Plugin::$operation.name$$suffix$Plugin::create_data
>>

copyDataCallback(operation, suffix) ::= <<
(::transport::dds::Transport::Copy_data)$operation.parent.scopedname$Plugin::$operation.name$$suffix$Plugin::copy_data
>>

destroyDataCallback(operation, suffix) ::= <<
(::transport::dds::Transport::Destroy_data)$operation.parent.scopedname$Plugin::$operation.name$$suffix$Plugin::destroy_data
>>

getHeaderRetCode(varname) ::= <<
$varname$._header().retCode()
>>

getHeaderRetMsg(varname) ::= <<
$varname$._header().retMsg()
>>

addParamToTopic(param, varname, isRequest) ::= <<
$if(param)$
$if(isRequest)$
$varname$.$param.name$($param.name$);
$else$
$if(param.typecode.primitive)$
$varname$.$param.name$($param.name$);
$else$
$varname$.$param.name$(std::move($param.name$));
$endif$
$endif$
$endif$
>>

extractParamFromTopic(param, varname, isReply) ::= <<
$if(param.typecode.primitive)$
$param.name$ = $varname$.$param.name$();
$else$ 
$param.name$ = std::move($varname$.$param.name$()); //TODO Probar que esto funciona.
$endif$ 
>>

copyHeaderInfo(reqvarname, repvarname) ::= <<
$repvarname$._header().clientId().value_1() = $reqvarname$._header().clientId().value_1();
$repvarname$._header().clientId().value_2() = $reqvarname$._header().clientId().value_2();
$repvarname$._header().clientId().value_3() = $reqvarname$._header().clientId().value_3();
$repvarname$._header().clientId().value_4() = $reqvarname$._header().clientId().value_4();
$repvarname$._header().requestSequenceNumber() = $reqvarname$._header().requestSequenceNumber();
>>

setHeaderSuccess(varname) ::= <<
$varname$._header().retCode(OPERATION_SUCCESSFUL);
>>

setHeaderServerInternalException(varname) ::= <<
$varname$._header().retCode(SERVER_INTERNAL_ERROR);
$varname$._header().retMsg(std::move(ex.what()));
>>

// TODO Todos los tipos. MEJORAR. size of 1 no deberia generar alignment.
serialized_size(param, var) ::= <<
$if(param.typecode.primitive)$
$var$ += $param.typecode.size$ + eprosima::Cdr::alignment($var$, $param.typecode.size$);
$else$
$endif$
>>

eprosimaTypesBool() ::= <<true>>

/** NEEDED BY RTI TYPES **/
charCasting() ::= <<>>

unsetReply() ::= <<>>

reqrepDestruction(type, reqrep, name, void) ::= <<>>

varComplexInitializeT(typeName, name) ::= <<>>

varComplexInitialize(variable) ::= <<>>

varComplexDelT(typeName, name) ::= <<>>

reqrepRefFinalize(type, reqrep, name) ::= <<>>
